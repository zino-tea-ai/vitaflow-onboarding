/**
 * NogicOS Minimal Chat Area
 * Premium Motion Design - Top-tier Animations
 */

import { useState, useRef, useEffect, useCallback, useMemo, memo } from 'react';
import type { KeyboardEvent } from 'react';
import { useChat } from '@ai-sdk/react';
import { DefaultChatTransport } from 'ai';
import { motion, AnimatePresence } from 'motion/react';
import { ArrowUp, ChevronRight, Square, Terminal, CheckCircle2, Loader2, AlertCircle } from 'lucide-react';
import ReactMarkdown from 'react-markdown';
import remarkGfm from 'remark-gfm';
import { cn } from '@/lib/utils';
import './styles/minimal-theme.css';

// === TOP-TIER SPRING CONFIGURATIONS ===
// Generated by Motion+ MCP for physics-accurate animations
const springs = {
  // Gentle entrance - 550ms with subtle overshoot
  gentle: { type: 'spring' as const, stiffness: 120, damping: 14 },
  // Snappy interactions - 250ms crisp response  
  snappy: { type: 'spring' as const, stiffness: 400, damping: 30 },
  // Smooth transitions - 400ms with medium bounce
  smooth: { type: 'spring' as const, stiffness: 200, damping: 20 },
  // Micro interactions - 200ms ultra responsive
  micro: { type: 'spring' as const, stiffness: 500, damping: 35 },
  // Expand/collapse - 300ms with slight bounce
  expand: { type: 'spring' as const, stiffness: 300, damping: 25 },
} as const;

interface MinimalChatAreaProps {
  apiUrl?: string;
  sessionId?: string;
  className?: string;
}

export function MinimalChatArea({
  apiUrl = 'http://localhost:8080/api/chat',
  sessionId = 'default',
  className,
}: MinimalChatAreaProps) {
  const textareaRef = useRef<HTMLTextAreaElement>(null);
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const [localInput, setLocalInput] = useState('');
  const [isFocused, setIsFocused] = useState(false);

  const {
    messages,
    sendMessage,
    stop,
    status, // 'idle' | 'pending' | 'streaming'
  } = useChat({
    transport: new DefaultChatTransport({
      api: apiUrl,
      body: { session_id: sessionId },
    }),
    onError: (err) => {
      console.error('[MinimalChatArea] Error:', err);
    },
  });

  // Derive loading state from useChat status
  const isLoading = status === 'pending' || status === 'streaming';
  const isActuallyStreaming = status === 'streaming';

  // Auto scroll - on new messages and during streaming
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);

  // Also scroll during streaming content updates
  useEffect(() => {
    if (isActuallyStreaming) {
      const scrollInterval = setInterval(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
      }, 300);
      return () => clearInterval(scrollInterval);
    }
  }, [isActuallyStreaming]);

  // Auto resize textarea with smooth transition
  useEffect(() => {
    if (textareaRef.current) {
      textareaRef.current.style.height = 'auto';
      textareaRef.current.style.height = `${Math.min(textareaRef.current.scrollHeight, 200)}px`;
    }
  }, [localInput]);

  const handleInputChange = useCallback((e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setLocalInput(e.target.value);
  }, []);

  const onSubmit = useCallback(async (e: React.FormEvent) => {
    e.preventDefault();
    if (localInput.trim() && !isLoading) {
      try {
        await sendMessage({ text: localInput.trim() });
        setLocalInput('');
      } catch (err) {
        console.error('[MinimalChatArea] Error:', err);
      }
    }
  }, [localInput, isLoading, sendMessage]);

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      onSubmit(e as unknown as React.FormEvent);
    }
  };

  const isEmpty = messages.length === 0;


  return (
    <div className={cn('minimal-main', className)}>
      {/* Grain Overlay for premium texture */}
      <div className="minimal-grain-overlay" aria-hidden="true" />
      
      {/* Chat Area */}
      <div className="minimal-chat">
        <div className="minimal-chat-inner">
          <AnimatePresence mode="wait">
            {isEmpty ? (
              <WelcomeScreen key="welcome" onExample={setLocalInput} />
            ) : (
              <motion.div
                key="messages"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ duration: 0.2 }}
              >
                <AnimatePresence initial={false}>
                  {messages.map((message, index) => (
                    <motion.div
                      key={message.id || `msg-${index}`}
                      initial={{ opacity: 0, y: 15, filter: 'blur(4px)' }}
                      animate={{ opacity: 1, y: 0, filter: 'blur(0px)' }}
                      transition={{ duration: 0.35, ease: [0.4, 0, 0.2, 1] }}
                      style={{ willChange: 'transform, opacity, filter' }}
                    >
                      <MinimalMessage
                        role={message.role as 'user' | 'assistant'}
                        content={message.content}
                        parts={message.parts as any}
                        isStreaming={isActuallyStreaming && index === messages.length - 1 && message.role === 'assistant'}
                      />
                    </motion.div>
                  ))}
                </AnimatePresence>

                <div ref={messagesEndRef} />
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </div>

      {/* Input Area with focus animation */}
      <motion.div 
        className="minimal-input-area"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ ...springs.smooth, delay: 0.1 }}
      >
        <div className="minimal-input-container">
          <form onSubmit={onSubmit}>
            <motion.div 
              className="minimal-input-box"
              animate={{
                boxShadow: isFocused 
                  ? '0 0 0 1px rgba(255,255,255,0.15), 0 4px 20px rgba(0,0,0,0.3)' 
                  : '0 0 0 1px rgba(255,255,255,0.06), 0 2px 8px rgba(0,0,0,0.2)',
              }}
              transition={{ duration: 0.2 }}
              style={{ willChange: 'box-shadow' }}
            >
              <textarea
                ref={textareaRef}
                value={localInput}
                onChange={handleInputChange}
                onKeyDown={handleKeyDown}
                onFocus={() => setIsFocused(true)}
                onBlur={() => setIsFocused(false)}
                placeholder="Message NogicOS..."
                rows={1}
                disabled={isLoading}
                className="minimal-textarea"
              />
              <AnimatePresence mode="wait">
                {isLoading ? (
                  <StopButton key="stop" onClick={stop} />
                ) : (
                  <SendButton key="send" disabled={!localInput.trim()} />
                )}
              </AnimatePresence>
            </motion.div>
          </form>
          <motion.div 
            className="minimal-input-meta"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.2, duration: 0.3 }}
          >
            <span className="minimal-input-hint">
              <kbd>Enter</kbd> to send · <kbd>Shift+Enter</kbd> for new line
            </span>
            <span className="minimal-model-badge">
              <motion.span 
                className="minimal-status-dot"
                animate={{ scale: [1, 1.2, 1] }}
                transition={{ duration: 2, repeat: Infinity, ease: 'easeInOut' }}
              />
              Claude Opus 4
            </span>
          </motion.div>
        </div>
      </motion.div>
    </div>
  );
}

// === ANIMATED COMPONENTS ===

// Premium Loading Dots with wave animation
function LoadingDots() {
  return (
    <div className="minimal-loading">
      {[0, 1, 2].map((i) => (
        <motion.span
          key={i}
          className="minimal-loading-dot"
          animate={{
            y: [0, -6, 0],
            opacity: [0.4, 1, 0.4],
          }}
          transition={{
            duration: 0.8,
            repeat: Infinity,
            delay: i * 0.15,
            ease: 'easeInOut',
          }}
          style={{ willChange: 'transform, opacity' }}
        />
      ))}
    </div>
  );
}

// Send Button with micro-interactions
function SendButton({ disabled }: { disabled: boolean }) {
  return (
    <motion.button
      type="submit"
      disabled={disabled}
      className="minimal-send-btn"
      initial={{ scale: 0.8, opacity: 0 }}
      animate={{ scale: 1, opacity: 1 }}
      exit={{ scale: 0.8, opacity: 0 }}
      whileHover={{ scale: disabled ? 1 : 1.05 }}
      whileTap={{ scale: disabled ? 1 : 0.92 }}
      transition={springs.micro}
      style={{ willChange: 'transform' }}
    >
      <motion.div
        animate={{ y: disabled ? 0 : [0, -1, 0] }}
        transition={{ duration: 0.3 }}
      >
        <ArrowUp className="w-4 h-4" />
      </motion.div>
    </motion.button>
  );
}

// Stop Button with pulse effect
function StopButton({ onClick }: { onClick: () => void }) {
  return (
    <motion.button
      type="button"
      onClick={onClick}
      className="minimal-send-btn minimal-send-btn--stop"
      initial={{ scale: 0.8, opacity: 0, rotate: -90 }}
      animate={{ scale: 1, opacity: 1, rotate: 0 }}
      exit={{ scale: 0.8, opacity: 0, rotate: 90 }}
      whileHover={{ scale: 1.05 }}
      whileTap={{ scale: 0.92 }}
      transition={springs.micro}
      style={{ 
        background: 'var(--m-gray-700)',
        willChange: 'transform',
      }}
    >
      <motion.div
        animate={{ scale: [1, 1.1, 1] }}
        transition={{ duration: 1.5, repeat: Infinity }}
      >
        <Square className="w-3 h-3" fill="currentColor" />
      </motion.div>
    </motion.button>
  );
}

// Welcome Screen - Bold, spacious, asymmetric layout
function WelcomeScreen({ onExample }: { onExample: (text: string) => void }) {
  const examples = [
    { text: 'Organize desktop', full: 'Organize my desktop files' },
    { text: 'Find recent files', full: 'Search recently modified files' },
    { text: 'Open Hacker News', full: 'Open Hacker News' },
    { text: 'Run git status', full: 'Run git status' },
  ];

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0, scale: 0.98 }}
      transition={{ duration: 0.4 }}
      className="minimal-welcome-v2"
    >
      {/* Hero Section - Large title with breathing room */}
      <div className="minimal-hero">
        <motion.h1 
          className="minimal-hero-title"
          initial={{ opacity: 0, y: 40 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.6, ease: [0.16, 1, 0.3, 1] }}
        >
          NogicOS
        </motion.h1>
        <motion.p 
          className="minimal-hero-subtitle"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ duration: 0.5, delay: 0.2 }}
        >
          AI that lives in your computer
        </motion.p>
      </div>

      {/* Quick Actions - Horizontal pill layout */}
      <motion.div 
        className="minimal-quick-actions"
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.35 }}
      >
        <span className="minimal-quick-label">Try</span>
        <div className="minimal-pills">
          {examples.map((example, i) => (
            <motion.button
              key={example.text}
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              transition={{ duration: 0.3, delay: 0.4 + i * 0.05 }}
              whileHover={{ scale: 1.02, backgroundColor: 'rgba(255,255,255,0.08)' }}
              whileTap={{ scale: 0.98 }}
              onClick={() => onExample(example.full)}
              className="minimal-pill"
            >
              {example.text}
            </motion.button>
          ))}
        </div>
      </motion.div>
    </motion.div>
  );
}

// Message Component - with smooth typewriter effect
interface MinimalMessageProps {
  role: 'user' | 'assistant';
  content?: string;
  parts?: any[];
  isStreaming?: boolean;
}

// Premium Typewriter with fade-in emergence effect
interface StreamingTextProps {
  text: string;
  isStreaming: boolean;
  onComplete?: () => void;
}

function StreamingText({ text, isStreaming, onComplete }: StreamingTextProps) {
  const containerRef = useRef<HTMLSpanElement>(null);
  const displayedRef = useRef(0);
  const textRef = useRef(text);
  const timeoutRef = useRef<NodeJS.Timeout>();
  const completedRef = useRef(false);
  const isStreamingRef = useRef(isStreaming);
  const onCompleteRef = useRef(onComplete);

  // Keep refs updated
  textRef.current = text;
  isStreamingRef.current = isStreaming;
  onCompleteRef.current = onComplete;

  // Simple display update
  const updateDisplay = (length: number) => {
    if (!containerRef.current) return;
    containerRef.current.textContent = textRef.current.slice(0, length);
  };

  // Start tick only once on mount
  useEffect(() => {
    const tick = () => {
      const target = textRef.current;
      const current = displayedRef.current;
      
      // If caught up with content, wait for more or complete
      if (current >= target.length) {
        if (!isStreamingRef.current && !completedRef.current) {
          // Streaming done and all content displayed - complete
          completedRef.current = true;
          onCompleteRef.current?.();
        } else {
          // Wait for more content
          timeoutRef.current = setTimeout(tick, 50);
        }
        return;
      }

      displayedRef.current = current + 1;
      updateDisplay(current + 1);

      // Adjust speed based on character type for perceived consistency
      const char = target[current];
      const isCJK = /[\u4e00-\u9fff\u3400-\u4dbf\uac00-\ud7af\u3040-\u309f\u30a0-\u30ff]/.test(char);
      let delay = isCJK ? 35 : 12; // CJK slower (more info per char), Latin faster

      timeoutRef.current = setTimeout(tick, delay);
    };

    tick();

    return () => {
      if (timeoutRef.current) clearTimeout(timeoutRef.current);
    };
  }, []); // Only run once on mount - refs handle updates

  return <span ref={containerRef} className="whitespace-pre-wrap" />;
}


// Tool Widget - displays tool invocations with status
interface ToolWidgetProps {
  tool: {
    type: string;  // 'tool-{toolName}' or 'dynamic-tool'
    toolCallId: string;
    toolName?: string;  // For dynamic-tool
    state: string;  // 'input-streaming' | 'input-available' | 'output-available' | etc.
    input?: Record<string, any>;
    output?: any;
    errorText?: string;
  };
}

const ToolWidget = memo(function ToolWidget({ tool }: ToolWidgetProps) {
  const [expanded, setExpanded] = useState(false);
  
  // Extract tool name from type (e.g., 'tool-list_directory' -> 'list_directory')
  const toolName = tool.toolName || tool.type?.replace(/^tool-/, '') || 'unknown';
  
  // Determine status based on state
  const isComplete = tool.state === 'output-available';
  const isError = tool.state === 'error' || !!tool.errorText;
  const isRunning = tool.state === 'input-streaming' || tool.state === 'input-available';
  
  // Format tool name for display
  const displayName = toolName
    .replace(/_/g, ' ')
    .replace(/([A-Z])/g, ' $1')
    .trim()
    .toLowerCase()
    .replace(/^./, c => c.toUpperCase());
  
  // Format input for display
  const inputSummary = tool.input 
    ? Object.entries(tool.input)
        .map(([k, v]) => `${k}: ${typeof v === 'string' ? v : JSON.stringify(v)}`)
        .join(', ')
    : '';

  return (
    <motion.div 
      className="tool-widget"
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.25, ease: [0.4, 0, 0.2, 1] }}
    >
      <div 
        className="tool-widget-header"
        onClick={() => setExpanded(e => !e)}
      >
        <div className="tool-widget-icon">
          {isComplete ? (
            <CheckCircle2 className="w-4 h-4 text-emerald-400" />
          ) : isError ? (
            <AlertCircle className="w-4 h-4 text-red-400" />
          ) : isRunning ? (
            <Loader2 className="w-4 h-4 text-neutral-400 animate-spin" />
          ) : (
            <Terminal className="w-4 h-4 text-neutral-500" />
          )}
        </div>
        <div className="tool-widget-info">
          <span className="tool-widget-name">{displayName}</span>
          {inputSummary && (
            <span className="tool-widget-args">{inputSummary.slice(0, 60)}{inputSummary.length > 60 ? '...' : ''}</span>
          )}
        </div>
        <span className={`tool-widget-chevron ${expanded ? 'open' : ''}`}>
          <ChevronRight className="w-3.5 h-3.5" />
        </span>
      </div>
      
      <AnimatePresence>
        {expanded && (tool.input || tool.output || tool.errorText) && (
          <motion.div 
            className="tool-widget-details"
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: 'auto' }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.25, ease: [0.4, 0, 0.2, 1] }}
          >
            {tool.input && (
              <div className="tool-widget-section">
                <span className="tool-widget-label">Input</span>
                <pre className="tool-widget-code">{JSON.stringify(tool.input, null, 2)}</pre>
              </div>
            )}
            {tool.output && (
              <div className="tool-widget-section">
                <span className="tool-widget-label">Output</span>
                <pre className="tool-widget-code">{typeof tool.output === 'string' ? tool.output : JSON.stringify(tool.output, null, 2)}</pre>
              </div>
            )}
            {tool.errorText && (
              <div className="tool-widget-section">
                <span className="tool-widget-label text-red-400">Error</span>
                <pre className="tool-widget-code text-red-300">{tool.errorText}</pre>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
});


const MinimalMessage = memo(function MinimalMessage({ role, content, parts, isStreaming }: MinimalMessageProps) {
  const [thinkingOpen, setThinkingOpen] = useState(true);
  const [thinkingComplete, setThinkingComplete] = useState(false);
  const [thinkingAnimationDone, setThinkingAnimationDone] = useState(false);
  const [textAnimating, setTextAnimating] = useState(true);
  const [roleVisible, setRoleVisible] = useState(false);
  const thinkingStartTime = useRef<number | null>(null);
  const isUser = role === 'user';

  // Extract text, reasoning, and tool invocations from parts
  const textContent = useMemo(() => 
    parts?.filter((p: any) => p.type === 'text').map((p: any) => p.text).join('') || content || '',
    [parts, content]
  );

  const reasoningText = useMemo(() => 
    parts?.filter((p: any) => p.type === 'reasoning').map((p: any) => p.text).join('') || '',
    [parts]
  );

  // Extract tool invocations (AI SDK stores them as 'tool-{toolName}' or 'dynamic-tool' parts)
  const toolInvocations = useMemo(() => 
    parts?.filter((p: any) => 
      p.type?.startsWith('tool-') || p.type === 'dynamic-tool'
    ) || [],
    [parts]
  );

  const hasReasoning = reasoningText.length > 0;
  const hasTools = toolInvocations.length > 0;
  
  // Debug: log parts structure for tool invocations
  useEffect(() => {
    if (parts && parts.length > 0) {
      const toolParts = parts.filter((p: any) => p.type?.startsWith('tool-') || p.type === 'dynamic-tool');
      if (toolParts.length > 0) {
        console.log('[ToolWidget] Tool parts:', toolParts.map((p: any) => ({
          type: p.type,
          state: p.state,
          toolCallId: p.toolCallId,
          hasInput: !!p.input,
          hasOutput: !!p.output,
        })));
      }
    }
  }, [parts]);
  
  // Show planning when streaming but no content yet
  const showPlanning = isStreaming && !hasReasoning && !textContent;
  
  // Show role after planning ends (for AI messages)
  useEffect(() => {
    if (isUser) {
      setRoleVisible(true);
    } else if (!showPlanning && !roleVisible) {
      const timer = setTimeout(() => setRoleVisible(true), 450); // Wait longer after planning
      return () => clearTimeout(timer);
    }
  }, [isUser, showPlanning, roleVisible]);
  
  // Set thinking start time when reasoning first appears
  useEffect(() => {
    if (hasReasoning && thinkingStartTime.current === null) {
      thinkingStartTime.current = Date.now();
    }
  }, [hasReasoning]);
  
  // Text should wait for thinking animation to complete
  const showText = !hasReasoning || thinkingComplete;
  
  // Text needs animation if: streaming, or just started showing after thinking
  const needsTextAnimation = isStreaming || textAnimating;

  // NogicOS label uses fixed timing for consistency
  const showRole = isUser ? true : roleVisible;

  return (
    <div className="minimal-message">
      {/* Role label - fades in after planning (no layout shift) */}
      <motion.div 
        className="minimal-message-role"
        initial={{ opacity: isUser ? 0 : 0, x: -8 }}
        animate={{ opacity: showRole ? 1 : 0, x: showRole ? 0 : -8 }}
        transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
      >
        {isUser ? 'You' : 'NogicOS'}
      </motion.div>
      
      <div className={`minimal-message-content ${isStreaming ? 'streaming' : ''}`}>
        {/* Planning → Thinking transition in single AnimatePresence for smooth handoff */}
        <AnimatePresence mode="wait">
          {showPlanning ? (
            <motion.div
              key="planning"
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -8 }}
              transition={{ 
                duration: 0.35, 
                delay: 0.7, // Wait longer for message to settle
                ease: [0.4, 0, 0.2, 1] 
              }}
              className="minimal-planning"
            >
              <LoadingDots />
              <span className="minimal-planning-text">Planning next moves</span>
            </motion.div>
          ) : hasReasoning ? (
            <motion.div
              key="thinking"
              className={cn(
                "minimal-thinking",
                isStreaming && !textContent && "thinking-active"
              )}
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0 }}
              transition={{ 
                duration: 0.35, 
                delay: 0.35, // Wait for NogicOS label to appear first
                ease: [0.4, 0, 0.2, 1] 
              }}
            >
              <div className="minimal-thinking-header" onClick={() => setThinkingOpen(o => !o)}>
                <span className={`minimal-thinking-chevron ${thinkingOpen ? 'open' : ''}`}>
                  <ChevronRight className="w-3 h-3" />
                </span>
                <span className="minimal-thinking-status">
                  {isStreaming && !textContent ? 'Planning next moves' : 'Thought process'}
                </span>
              </div>
              <AnimatePresence>
                {thinkingOpen && (
                  <motion.div 
                    className="minimal-thinking-content"
                    initial={{ opacity: 0, height: 0 }}
                    animate={{ opacity: 1, height: 'auto' }}
                    exit={{ opacity: 0, height: 0 }}
                    transition={{ duration: 0.4, ease: [0.4, 0, 0.2, 1] }}
                  >
                    {thinkingAnimationDone ? (
                      // Already played - show text directly
                      <span className="whitespace-pre-wrap">{reasoningText}</span>
                    ) : (
                      // First time - play typewriter animation
                      <StreamingText 
                        text={reasoningText} 
                        isStreaming={isStreaming && !textContent}
                        onComplete={() => {
                          setThinkingAnimationDone(true);
                          // Ensure minimum display time (1.5s) for rhythm consistency
                          const startTime = thinkingStartTime.current || Date.now();
                          const elapsed = Date.now() - startTime;
                          const minDisplayTime = 1500;
                          const remainingTime = Math.max(0, minDisplayTime - elapsed);
                          setTimeout(() => setThinkingComplete(true), remainingTime + 300);
                        }}
                      />
                    )}
                  </motion.div>
                )}
              </AnimatePresence>
            </motion.div>
          ) : null}
        </AnimatePresence>

        {/* Tool invocations - show between thinking and text */}
        <AnimatePresence>
          {hasTools && (
            <motion.div
              className="minimal-tools"
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.3, ease: [0.4, 0, 0.2, 1] }}
            >
              {toolInvocations.map((tool: any, index: number) => (
                <ToolWidget key={tool.toolCallId || index} tool={tool} />
              ))}
            </motion.div>
          )}
        </AnimatePresence>

        {/* Text content - waits for thinking to complete, then uses typewriter */}
        <AnimatePresence>
          {textContent && showText && (
            <motion.div 
              className="minimal-prose"
              initial={{ opacity: 0, y: 8 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.35, ease: [0.4, 0, 0.2, 1] }}
            >
              {needsTextAnimation ? (
                <p>
                  <StreamingText 
                    text={textContent} 
                    isStreaming={isStreaming}
                    onComplete={() => {
                      if (hasReasoning) {
                        setTimeout(() => setThinkingOpen(false), 500);
                      }
                      setTextAnimating(false);
                    }}
                  />
                  {isStreaming && <span className="minimal-cursor" />}
                </p>
              ) : (
                <ReactMarkdown 
                  remarkPlugins={[remarkGfm]}
                  components={{
                    h1: ({ children }) => <h1 className="text-xl font-semibold text-white mt-4 mb-2">{children}</h1>,
                    h2: ({ children }) => <h2 className="text-lg font-semibold text-white mt-3 mb-2">{children}</h2>,
                    h3: ({ children }) => <h3 className="text-base font-medium text-white mt-2 mb-1">{children}</h3>,
                    p: ({ children }) => <p className="mb-3 last:mb-0">{children}</p>,
                    ul: ({ children }) => <ul className="list-disc list-inside mb-3 space-y-1">{children}</ul>,
                    ol: ({ children }) => <ol className="list-decimal list-inside mb-3 space-y-1">{children}</ol>,
                    li: ({ children }) => <li className="text-neutral-300">{children}</li>,
                    strong: ({ children }) => <strong className="font-semibold text-white">{children}</strong>,
                    em: ({ children }) => <em className="italic text-neutral-200">{children}</em>,
                    code: ({ className, children }) => {
                      const isBlock = className?.includes('language-');
                      return isBlock ? (
                        <pre className="bg-neutral-900 rounded-lg p-4 my-3 overflow-x-auto">
                          <code className="text-sm font-mono text-neutral-200">{children}</code>
                        </pre>
                      ) : (
                        <code className="bg-neutral-800 px-1.5 py-0.5 rounded text-sm font-mono text-neutral-200">{children}</code>
                      );
                    },
                    pre: ({ children }) => <>{children}</>,
                    a: ({ href, children }) => (
                      <a href={href} className="text-white underline underline-offset-2 hover:text-neutral-300" target="_blank" rel="noopener noreferrer">
                        {children}
                      </a>
                    ),
                    blockquote: ({ children }) => (
                      <blockquote className="border-l-2 border-neutral-700 pl-4 my-3 text-neutral-400 italic">{children}</blockquote>
                    ),
                    hr: () => <hr className="border-neutral-800 my-4" />,
                  }}
                >
                  {textContent}
                </ReactMarkdown>
              )}
            </motion.div>
          )}
        </AnimatePresence>

      </div>
    </div>
  );
});
