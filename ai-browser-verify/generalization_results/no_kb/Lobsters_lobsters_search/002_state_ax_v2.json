{"role": "document", "name": "Search | Lobsters", "properties": {}, "bounding_box": {"x": 182.57144165039062, "y": 13.330357551574707, "width": 900.0000610351562, "height": 6983.3662109375}, "tag_name": "body", "id": 0, "children": [{"role": "link", "name": "Lobsters (Current traffic: 20%)", "properties": {"url": "/"}, "bounding_box": {"x": 200.00001525878906, "y": 18.330358505249023, "width": 18, "height": 18}, "tag_name": "a", "id": 2, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Lobsters (Current traffic: 20%)"}}]}, {"role": "link", "name": "Active", "properties": {"url": "/active"}, "bounding_box": {"x": 226.00001525878906, "y": 18.330358505249023, "width": 40.017860412597656, "height": 24.85714340209961}, "tag_name": "a", "id": 5, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Active", "exact": true}}]}, {"role": "link", "name": "Recent", "properties": {"url": "/recent"}, "bounding_box": {"x": 274.01788330078125, "y": 18.330358505249023, "width": 44.455360412597656, "height": 24.85714340209961}, "tag_name": "a", "id": 6, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Recent"}}]}, {"role": "link", "name": "Comments", "properties": {"url": "/comments"}, "bounding_box": {"x": 326.4732360839844, "y": 18.330358505249023, "width": 68.89286041259766, "height": 24.85714340209961}, "tag_name": "a", "id": 7, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Comments"}}]}, {"role": "link", "name": "Search", "properties": {"url": "/search"}, "bounding_box": {"x": 403.3660888671875, "y": 18.330358505249023, "width": 52.47321701049805, "height": 24.85714340209961}, "tag_name": "a", "id": 8, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Search"}}]}, {"role": "link", "name": "Login", "properties": {"url": "/login"}, "bounding_box": {"x": 1043.71435546875, "y": 18.330358505249023, "width": 36.28571701049805, "height": 24.85714340209961}, "tag_name": "a", "id": 9, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Login"}}]}, {"role": "heading", "name": "Search", "properties": {"level": 1}, "bounding_box": {"x": 226.00001525878906, "y": 56.187503814697266, "width": 854.0000610351562, "height": 19.330358505249023}, "tag_name": "h1", "id": 3, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Search", "exact": true}}]}, {"role": "form", "name": "Search", "properties": {}, "bounding_box": {"x": 226.00001525878906, "y": 91.51786041259766, "width": 854.0000610351562, "height": 97.1339340209961}, "tag_name": "form", "id": 4, "children": [{"role": "searchbox", "name": "Search query", "properties": {}, "bounding_box": {"x": 226.00001525878906, "y": 91.51786041259766, "width": 314, "height": 26.473215103149414}, "tag_name": "input", "id": 6, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "searchbox", "name": "Search query"}}]}, {"role": "button", "name": "Search", "properties": {}, "bounding_box": {"x": 543.7053833007812, "y": 93.08928680419922, "width": 63.38393020629883, "height": 23.142858505249023}, "tag_name": "input", "id": 7, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "button", "name": "Search"}}]}, {"role": "group", "name": "Search", "properties": {}, "bounding_box": {"x": 226.00001525878906, "y": 133.99107360839844, "width": 854.0000610351562, "height": 19.330358505249023}, "tag_name": "fieldset", "id": 6, "children": [{"role": "radio", "name": "Stories", "properties": {"checked": false}, "bounding_box": {"x": 319.33038330078125, "y": 137.5625, "width": 13.000000953674316, "height": 13.000000953674316}, "tag_name": "input", "id": 10, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "radio", "name": "Stories"}}]}, {"role": "radio", "name": "Comments", "properties": {"checked": true}, "bounding_box": {"x": 397.52679443359375, "y": 137.5625, "width": 13.000000953674316, "height": 13.000000953674316}, "tag_name": "input", "id": 11, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "radio", "name": "Comments"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "group", "name": "Search"}}]}, {"role": "group", "name": "Order By", "properties": {}, "bounding_box": {"x": 226.00001525878906, "y": 169.32144165039062, "width": 854.0000610351562, "height": 19.330358505249023}, "tag_name": "fieldset", "id": 7, "children": [{"role": "radio", "name": "Newest", "properties": {"checked": true}, "bounding_box": {"x": 319.33038330078125, "y": 172.8928680419922, "width": 13.000000953674316, "height": 13.000000953674316}, "tag_name": "input", "id": 11, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "radio", "name": "Newest"}}]}, {"role": "radio", "name": "Relevance", "properties": {"checked": false}, "bounding_box": {"x": 400.4910888671875, "y": 172.8928680419922, "width": 13.000000953674316, "height": 13.000000953674316}, "tag_name": "input", "id": 12, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "radio", "name": "Relevance"}}]}, {"role": "radio", "name": "Score", "properties": {"checked": false}, "bounding_box": {"x": 500.1875305175781, "y": 172.8928680419922, "width": 13.000000953674316, "height": 13.000000953674316}, "tag_name": "input", "id": 13, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "radio", "name": "Score"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "group", "name": "Order By"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "form", "name": "Search"}}]}, {"role": "group", "name": "", "properties": {"expanded": false}, "bounding_box": {"x": 218.57144165039062, "y": 201.98214721679688, "width": 854.0000610351562, "height": 33.23214340209961}, "tag_name": "details", "id": 6, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "group", "name": ""}}]}, {"role": "link", "name": "\u25b3 23", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 259.875, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 12, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 23"}}]}, {"role": "link", "name": "LesleyLai", "properties": {"url": "/~LesleyLai"}, "bounding_box": {"x": 240.0982208251953, "y": 244.1607208251953, "width": 53.50893020629883, "height": 14.285715103149414}, "tag_name": "a", "id": 16, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "LesleyLai"}}]}, {"role": "link", "name": "23 hours ago", "properties": {"url": "/c/iwfwiq"}, "bounding_box": {"x": 297.1339416503906, "y": 244.1607208251953, "width": 73.92857360839844, "height": 14.285715103149414}, "tag_name": "a", "id": 17, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 297.1339416503906, "y": 244.1607208251953, "width": 73.92857360839844, "height": 14.285715103149414}, "tag_name": "time", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "23 hours ago"}}]}, {"role": "link", "name": "Your favorite pieces of technical writing?", "properties": {"url": "/s/8ugoxw/your_favorite_pieces_technical_writing"}, "bounding_box": {"x": 402.2946472167969, "y": 244.1607208251953, "width": 225.48214721679688, "height": 14.285715103149414}, "tag_name": "a", "id": 16, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Your favorite pieces of technical writing?"}}]}, {"role": "heading", "name": "Just writing down what popped into my head. Everything Bob Nystrom: Game Programming Patterns, Crafting Interpreters, and blog. Other blog posts: Simple but Powerful Pratt Parsing Graphics Pipelines for Young Bloods Books: Ray Tracing in One Weekend Real World OCaml Brown's Rust book experiment Rust Atomics and Locks", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 261.3035888671875, "width": 700.0000610351562, "height": 232.50001525878906}, "tag_name": "div", "id": 13, "children": [{"role": "link", "name": "Game Programming Patterns", "properties": {"url": "https://gameprogrammingpatterns.com/"}, "bounding_box": {"x": 377.3035888671875, "y": 293.5446472167969, "width": 182.07144165039062, "height": 15.428571701049805}, "tag_name": "a", "id": 16, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Game Programming Patterns"}}]}, {"role": "link", "name": "Crafting Interpreters", "properties": {"url": "https://www.craftinginterpreters.com/"}, "bounding_box": {"x": 567.1607666015625, "y": 293.5446472167969, "width": 124.50000762939453, "height": 15.428571701049805}, "tag_name": "a", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Crafting Interpreters"}}]}, {"role": "link", "name": "blog", "properties": {"url": "https://journal.stuffwithstuff.com/"}, "bounding_box": {"x": 726.6964721679688, "y": 293.5446472167969, "width": 26.473215103149414, "height": 15.428571701049805}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "blog"}}]}, {"role": "link", "name": "Simple but Powerful Pratt Parsing", "properties": {"url": "https://matklad.github.io/2020/04/13/simple-but-powerful-pratt-parsing.html"}, "bounding_box": {"x": 258.5714416503906, "y": 346.20538330078125, "width": 209.32144165039062, "height": 15.428571701049805}, "tag_name": "a", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Simple but Powerful Pratt Parsing"}}]}, {"role": "link", "name": "Graphics Pipelines for Young Bloods", "properties": {"url": "https://www.jeremyong.com/cpp/2021/05/20/graphics-pipelines-for-young-bloods/"}, "bounding_box": {"x": 258.5714416503906, "y": 365.5357360839844, "width": 226.48214721679688, "height": 15.428571701049805}, "tag_name": "a", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Graphics Pipelines for Young Bloods"}}]}, {"role": "link", "name": "Ray Tracing in One Weekend", "properties": {"url": "https://raytracing.github.io/books/RayTracingInOneWeekend.html"}, "bounding_box": {"x": 258.5714416503906, "y": 418.1964416503906, "width": 182.61607360839844, "height": 15.428571701049805}, "tag_name": "a", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Ray Tracing in One Weekend"}}]}, {"role": "link", "name": "Real World OCaml", "properties": {"url": "https://dev.realworldocaml.org/"}, "bounding_box": {"x": 258.5714416503906, "y": 437.52679443359375, "width": 116.43750762939453, "height": 15.428571701049805}, "tag_name": "a", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Real World OCaml"}}]}, {"role": "link", "name": "Brown's Rust book experiment", "properties": {"url": "https://rust-book.cs.brown.edu/"}, "bounding_box": {"x": 258.5714416503906, "y": 456.857177734375, "width": 189.42857360839844, "height": 15.428571701049805}, "tag_name": "a", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Brown's Rust book experiment"}}]}, {"role": "link", "name": "Rust Atomics and Locks", "properties": {"url": "https://marabos.nl/atomics/"}, "bounding_box": {"x": 258.5714416503906, "y": 476.1875305175781, "width": 149.40179443359375, "height": 15.428571701049805}, "tag_name": "a", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Rust Atomics and Locks"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Just writing down what popped into my head. Everything Bob Nystrom: Game Programming Patterns, Crafting Interpreters, and blog. Other blog posts: Simple but Powerful Pratt Parsing Graphics Pipelines for Young Bloods Books: Ray Tracing in One Weekend Real World OCaml Brown's Rust book experiment Rust Atomics and Locks"}}]}, {"role": "link", "name": "\u25b3 2", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 523.794677734375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 13, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 2", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "xnacly", "properties": {"url": "/~xnacly"}, "bounding_box": {"x": 240.0982208251953, "y": 508.08038330078125, "width": 35.892860412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "xnacly"}}]}, {"role": "link", "name": "2 days ago", "properties": {"url": "/c/fhidkl"}, "bounding_box": {"x": 317.5357360839844, "y": 508.08038330078125, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 18, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 317.5357360839844, "y": 508.08038330078125, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "2 days ago"}}]}, {"role": "link", "name": "What are you doing this week?", "properties": {"url": "/s/k9rvab/what_are_you_doing_this_week"}, "bounding_box": {"x": 410.95538330078125, "y": 508.08038330078125, "width": 173.1607208251953, "height": 14.285715103149414}, "tag_name": "a", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "What are you doing this week?"}}]}, {"role": "heading", "name": "Porting my (high performance) c based programming language interpreter to rust because I am going insane in my abstractions. Also experimenting with bevy and card games. And finally going back to doing work in my sql lsp and static analyser.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 525.2232666015625, "width": 700.0000610351562, "height": 69.1875}, "tag_name": "div", "id": 14, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Porting my (high performance) c based programming language interpreter to rust because I am going insane in my abstractions. Also experimenting with bevy and card games. And finally going back to doing work in my sql lsp and static analyser."}}]}, {"role": "link", "name": "\u25b3 19", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 624.4017944335938, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 14, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 19"}}]}, {"role": "link", "name": "cole-k", "properties": {"url": "/~cole-k"}, "bounding_box": {"x": 240.0982208251953, "y": 608.6875, "width": 33.78571701049805, "height": 14.285715103149414}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "cole-k", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "4 days ago", "properties": {"url": "/c/u8rvah"}, "bounding_box": {"x": 315.4285888671875, "y": 608.6875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 19, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 315.4285888671875, "y": 608.6875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "4 days ago"}}]}, {"role": "link", "name": "What do people love about Rust?", "properties": {"url": "/s/uo16ri/what_do_people_love_about_rust"}, "bounding_box": {"x": 408.8482360839844, "y": 608.6875, "width": 187.25894165039062, "height": 14.285715103149414}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "What do people love about Rust?"}}]}, {"role": "heading", "name": "I actually think Rust does error handling pretty well. Errors are just (one constructor of) an algebraic datatype, and the language has ? + enough built-ins to make short-circuiting and error-handling ergonomic while reaping the benefits of having your errors just be data. (Some) people laud Go for making errors values, and Rust's treatment is in my opinion strictly better (but I've basically never written Go). Unfortunately the type system is rigid in a way that makes it not ergonomic to \"compose\" multiple error types*, e.g. if you wanted to call a function which errors with FooError and then a function which errors with a BarError. This is where I have found anyhow to be useful. But most of the code I write has just a single error type or I just brazenly put .unwrap() etc. in fallible functions (I mean yes, your file read could fail, but I am cool with my function just crashing with the file read error in that case; I do not write Professional Rust!). Rust makes a lot more choices explicit compared to other programming languages, so don't be afraid to put .unwrap() or .clone() or whatever in your code to get it to work, especially at a first pass. You don't have to have perfectly \"clean\" and \"Rusty\" code, whatever that means. * I did some digging and this also happens in Haskell too; again I don't write good code, so of course never ran into these issues myself", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 625.8303833007812, "width": 700.0000610351562, "height": 329.15179443359375}, "tag_name": "div", "id": 15, "children": [{"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 357.14288330078125, "y": 651.6428833007812, "width": 7.000000476837158, "height": 13.714286804199219}, "tag_name": "code", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "in my opinion strictly better", "properties": {"url": "https://lobste.rs/s/vd6all/why_go_s_error_handling_is_awesome#c_kjiwav"}, "bounding_box": {"x": 295.6071472167969, "y": 689.732177734375, "width": 165.73214721679688, "height": 15.428571701049805}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "in my opinion strictly better"}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 546.1785888671875, "y": 735.9642944335938, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 849.6517944335938, "y": 735.9642944335938, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 385.89288330078125, "y": 755.294677734375, "width": 42, "height": 13.714286804199219}, "tag_name": "code", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 3}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 690.1339721679688, "y": 781.6250610351562, "width": 63.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 4}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 218.57144165039062, "y": 865.9464721679688, "width": 63.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 5}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 301.8035888671875, "y": 865.9464721679688, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 6}}]}, {"role": "link", "name": "this also happens in Haskell too", "properties": {"url": "https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html"}, "bounding_box": {"x": 372.6785888671875, "y": 911.0357666015625, "width": 196.90179443359375, "height": 15.428571701049805}, "tag_name": "a", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "this also happens in Haskell too"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "I actually think Rust does error handling pretty well. Errors are just (one constructor of) an algebraic datatype, and the language has ? + enough built-ins to make short-circuiting and error-handling ergonomic while reaping the benefits of having your errors just be data. (Some) people laud Go for making errors values, and Rust's treatment is in my opinion strictly better (but I've basically never written Go). Unfortunately the type system is rigid in a way that makes it not ergonomic to \"compose\" multiple error types*, e.g. if you wanted to call a function which errors with FooError and then a function which errors with a BarError. This is where I have found anyhow to be useful. But most of the code I write has just a single error type or I just brazenly put .unwrap() etc. in fallible functions (I mean yes, your file read could fail, but I am cool with my function just crashing with the file read error in that case; I do not write Professional Rust!). Rust makes a lot more choices explicit compared to other programming languages, so don't be afraid to put .unwrap() or .clone() or whatever in your code to get it to work, especially at a first pass. You don't have to have perfectly \"clean\" and \"Rusty\" code, whatever that means. * I did some digging and this also happens in Haskell too; again I don't write good code, so of course never ran into these issues myself"}}]}, {"role": "link", "name": "\u25b3 4", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 984.9732666015625, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 15, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 4", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "dpc_pw", "properties": {"url": "/~dpc_pw"}, "bounding_box": {"x": 240.0982208251953, "y": 969.2589721679688, "width": 43.65178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "dpc_pw"}}]}, {"role": "link", "name": "6 days ago", "properties": {"url": "/c/x2ulp1"}, "bounding_box": {"x": 325.2946472167969, "y": 969.2589721679688, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 20, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 325.2946472167969, "y": 969.2589721679688, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "6 days ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "Please Just Try HTMX", "properties": {"url": "/s/dicrsi/please_just_try_htmx"}, "bounding_box": {"x": 418.71429443359375, "y": 969.2589721679688, "width": 125.95536041259766, "height": 14.285715103149414}, "tag_name": "a", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Please Just Try HTMX"}}]}, {"role": "heading", "name": "It's not strictly about HTMX, but in a Rust codebase I use maud for templating and have as many functions building html things as needed. I have functions returning buttons, forms, etc. with the same classes, etc. . And I have functions making whole pages with elements of pages being arguments to it. So I reuse html just like a I reuse code. I'll have render_page, or I'll render_navbar. For more complex things, I'll add a a builder pattern with bon.rs to make things customizable, etc. Everything is typed, and I can tell that to render a navbar, I need to pass a user session, no room for typing mistakes, mismatched tags, etc. The requests handler just returns a whole page or just a given element, or even one or the other based on htmx header. It's quite easy and natural actually - reusing code and passing values is ... the most basic there is in programming. Not sure why web devs keep inventing so many layers of abstractions there. Especially trying to maintain a separate template in a separate file, using separate templating syntax, etc. seems completely counterproductive. Use the code, Luke. You already have a programming language, why invent another one just to look at something so ugly as raw html.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 986.40185546875, "width": 700.0000610351562, "height": 250.1607208251953}, "tag_name": "div", "id": 16, "children": [{"role": "link", "name": "render_page", "properties": {"url": "https://github.com/dpc/rostra/blob/c57f2d39e8e73dcb3f60b415d5413f7c4fe9de0d/crates/rostra-web-ui/src/fragment.rs#L28"}, "bounding_box": {"x": 346.5446472167969, "y": 1050.3035888671875, "width": 77, "height": 15.428571701049805}, "tag_name": "a", "id": 18, "children": [{"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 346.5446472167969, "y": 1050.875, "width": 77, "height": 13.714286804199219}, "tag_name": "code", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "render_page"}}]}, {"role": "link", "name": "render_navbar", "properties": {"url": "https://github.com/dpc/rostra/blob/c57f2d39e8e73dcb3f60b415d5413f7c4fe9de0d/crates/rostra-web-ui/src/routes/post.rs#L71"}, "bounding_box": {"x": 464.33929443359375, "y": 1050.3035888671875, "width": 91.00000762939453, "height": 15.428571701049805}, "tag_name": "a", "id": 19, "children": [{"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 464.33929443359375, "y": 1050.875, "width": 91.00000762939453, "height": 13.714286804199219}, "tag_name": "code", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "render_navbar"}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 218.57144165039062, "y": 1070.2054443359375, "width": 42, "height": 13.714286804199219}, "tag_name": "code", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 294.83929443359375, "y": 1089.5357666015625, "width": 49.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "It's not strictly about HTMX, but in a Rust codebase I use maud for templating and have as many functions building html things as needed. I have functions returning buttons, forms, etc. with the same classes, etc. . And I have functions making whole pages with elements of pages being arguments to it. So I reuse html just like a I reuse code. I'll have render_page, or I'll render_navbar. For more complex things, I'll add a a builder pattern with bon.rs to make things customizable, etc. Everything is typed, and I can tell that to render a navbar, I need to pass a user session, no room for typing mistakes, mismatched tags, etc. The requests handler just returns a whole page or just a given element, or even one or the other based on htmx header. It's quite easy and natural actually - reusing code and passing values is ... the most basic there is in programming. Not sure why web devs keep inventing so many layers of abstractions there. Especially trying to maintain a separate template in a separate file, using separate templating syntax, etc. seems completely counterproductive. Use the code, Luke. You already have a programming language, why invent another one just to look at something so ugly as raw html."}}]}, {"role": "link", "name": "\u25b3 1", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 1266.5535888671875, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 16, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 1", "exact": true}}]}, {"role": "link", "name": "amadu", "properties": {"url": "/~amadu"}, "bounding_box": {"x": 240.0982208251953, "y": 1250.83935546875, "width": 38.72321701049805, "height": 14.285715103149414}, "tag_name": "a", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "amadu"}}]}, {"role": "link", "name": "6 days ago", "properties": {"url": "/c/l8pfqv"}, "bounding_box": {"x": 282.3482360839844, "y": 1250.83935546875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 21, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 282.3482360839844, "y": 1250.83935546875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "6 days ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "I Tried Gleam for Advent of Code, and I Get the Hype", "properties": {"url": "/s/aoqsqp/i_tried_gleam_for_advent_code_i_get_hype"}, "bounding_box": {"x": 375.76788330078125, "y": 1250.83935546875, "width": 297.7410888671875, "height": 14.285715103149414}, "tag_name": "a", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "I Tried Gleam for Advent of Code, and I Get the Hype"}}]}, {"role": "heading", "name": "Looks like Gleam is the next programming language to try. I love Elixir and Rust, and Gleam looks like a good alternative", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 1267.982177734375, "width": 700.0000610351562, "height": 49.85714340209961}, "tag_name": "div", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Looks like Gleam is the next programming language to try. I love Elixir and Rust, and Gleam looks like a good alternative"}}]}, {"role": "link", "name": "\u25b3 3", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 1347.8304443359375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 3", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "cole-k", "properties": {"url": "/~cole-k"}, "bounding_box": {"x": 240.0982208251953, "y": 1332.1160888671875, "width": 33.78571701049805, "height": 14.285715103149414}, "tag_name": "a", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "cole-k", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "6 days ago", "properties": {"url": "/c/f3exhd"}, "bounding_box": {"x": 277.4107360839844, "y": 1332.1160888671875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 22, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 277.4107360839844, "y": 1332.1160888671875, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "6 days ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "The Wrong Question About Type Systems", "properties": {"url": "/s/sfjtvo/wrong_question_about_type_systems"}, "bounding_box": {"x": 370.5982360839844, "y": 1332.1160888671875, "width": 235.3303680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "The Wrong Question About Type Systems", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "heading", "name": "I think few proponents of (static) type systems would claim that types would catch these bugs, especially not for the exemplar typed languages Typescript and Go. Though I do believe there is merit in having stronger type systems that allow for tighter coupling between code and expectation, I think that is a discussion for a blog post comparing Haskell to Lean. It is still possible for type systems to have utility if they only catch small bugs. I mostly program in statically typed languages, but sometimes I write a quick Python utility program. It is only after rerunning your code 6 times to fix all of the typos and silly mistakes that you can truly appreciate the splendor of your code Just Working on its first successful compilation. And --- of course --- I can and should be using a linter or what-have-you that would detect all of these problems, but a sufficiently powerful linter should converge to some kind of a type system anyway. There are enough things to keep track of when programming (like the aforementioned disconnects between code and reality). I prefer to offload as much menial validation to my computer as is reasonably possible. And I am optimistic about what can be done to alleviate the burdens this brings, such as what the author alludes to in the last quoted sentence. I do think that having a good REPL is a (possibly huge) boon to a language (where is the Rust REPL?), but I am not sure that a static type system precludes one. And even compiled languages can have serviceable REPLs (such as GHCi).", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 1349.259033203125, "width": 700.0000610351562, "height": 452.1339416503906}, "tag_name": "div", "id": 18, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 1353.4554443359375, "width": 693.0000610351562, "height": 77.3214340209961}, "tag_name": "blockquote", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "I think few proponents of (static) type systems would claim that types would catch these bugs, especially not for the exemplar typed languages Typescript and Go. Though I do believe there is merit in having stronger type systems that allow for tighter coupling between code and expectation, I think that is a discussion for a blog post comparing Haskell to Lean. It is still possible for type systems to have utility if they only catch small bugs. I mostly program in statically typed languages, but sometimes I write a quick Python utility program. It is only after rerunning your code 6 times to fix all of the typos and silly mistakes that you can truly appreciate the splendor of your code Just Working on its first successful compilation. And --- of course --- I can and should be using a linter or what-have-you that would detect all of these problems, but a sufficiently powerful linter should converge to some kind of a type system anyway. There are enough things to keep track of when programming (like the aforementioned disconnects between code and reality). I prefer to offload as much menial validation to my computer as is reasonably possible. And I am optimistic about what can be done to alleviate the burdens this brings, such as what the author alludes to in the last quoted sentence. I do think that having a good REPL is a (possibly huge) boon to a language (where is the Rust REPL?), but I am not sure that a static type system precludes one. And even compiled languages can have serviceable REPLs (such as GHCi)."}}]}, {"role": "link", "name": "\u25b3 7", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 1831.384033203125, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 7"}}]}, {"role": "link", "name": "hc", "properties": {"url": "/~hc"}, "bounding_box": {"x": 240.0982208251953, "y": 1815.669677734375, "width": 13.375000953674316, "height": 14.285715103149414}, "tag_name": "a", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "hc"}}]}, {"role": "link", "name": "7 days ago", "properties": {"url": "/c/aitvn3"}, "bounding_box": {"x": 257, "y": 1815.669677734375, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 23, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 257, "y": 1815.669677734375, "width": 61.955360412597656, "height": 14.285715103149414}, "tag_name": "time", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "7 days ago"}}]}, {"role": "link", "name": "The Wrong Question About Type Systems", "properties": {"url": "/s/sfjtvo/wrong_question_about_type_systems"}, "bounding_box": {"x": 350.1875305175781, "y": 1815.669677734375, "width": 235.3303680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "The Wrong Question About Type Systems", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "heading", "name": "this is comparing clojure to a couple of the weakest static type systems (typescript, and go. java would be similar) typescript is especially bad, because the only purpose of the types is to cause compiler errors and maybe generate docs. the compiler checks the types, and then erases them go's types are a little better, since they at least mean the compiler knows the offset of fields. but go doesn't have overloading or anything. and if you're passing by interface, it's basically the same as using deftype/defrecord in clojure, minus the static check i don't mean that the conclusion is bad. for some ways of programming, clojure is a fine language and you won't miss them. but, i don't think the comparison tells you much, unless you look at type systems like C#, rust, haskell, or C++, where the types are doing more work", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 1832.8126220703125, "width": 700.0000610351562, "height": 225.50001525878906}, "tag_name": "div", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "this is comparing clojure to a couple of the weakest static type systems (typescript, and go. java would be similar) typescript is especially bad, because the only purpose of the types is to cause compiler errors and maybe generate docs. the compiler checks the types, and then erases them go's types are a little better, since they at least mean the compiler knows the offset of fields. but go doesn't have overloading or anything. and if you're passing by interface, it's basically the same as using deftype/defrecord in clojure, minus the static check i don't mean that the conclusion is bad. for some ways of programming, clojure is a fine language and you won't miss them. but, i don't think the comparison tells you much, unless you look at type systems like C#, rust, haskell, or C++, where the types are doing more work"}}]}, {"role": "link", "name": "\u25b3 10", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 2088.3037109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 10", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "BenjaminRi", "properties": {"url": "/~BenjaminRi"}, "bounding_box": {"x": 240.0982208251953, "y": 2072.58935546875, "width": 64.75, "height": 14.285715103149414}, "tag_name": "a", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "BenjaminRi", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "13 days ago", "properties": {"url": "/c/wynopa"}, "bounding_box": {"x": 346.39288330078125, "y": 2072.58935546875, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 24, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 346.39288330078125, "y": 2072.58935546875, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 25, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "13 days ago"}}]}, {"role": "link", "name": "Let's Embed a Go Program into the Linux Kernel", "properties": {"url": "/s/x49jb2/let_s_embed_go_program_into_linux_kernel"}, "bounding_box": {"x": 446.857177734375, "y": 2072.58935546875, "width": 272.0089416503906, "height": 14.285715103149414}, "tag_name": "a", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Let's Embed a Go Program into the Linux Kernel"}}]}, {"role": "heading", "name": "Haha you're giving me ideas... \"In the kernel mailing list, Linus Torvalds begrudgingly admitted that the opposition to Rust had not abated but instead grown and that it was no longer tenable. To resolve the tension among the Linux kernel developers, which seemed like it could escalate at any given time, he made the decision to meet those who demand a safer language in the Linux kernel halfway, opting for the less strict and easier to learn programming language Go.\"", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 2089.732177734375, "width": 700.0000610351562, "height": 107.84822082519531}, "tag_name": "div", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Haha you're giving me ideas... \"In the kernel mailing list, Linus Torvalds begrudgingly admitted that the opposition to Rust had not abated but instead grown and that it was no longer tenable. To resolve the tension among the Linux kernel developers, which seemed like it could escalate at any given time, he made the decision to meet those who demand a safer language in the Linux kernel halfway, opting for the less strict and easier to learn programming language Go.\""}}]}, {"role": "link", "name": "\u25b3 2", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 2227.571533203125, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 2", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "refi64", "properties": {"url": "/~refi64"}, "bounding_box": {"x": 240.0982208251953, "y": 2211.857177734375, "width": 31.678573608398438, "height": 14.285715103149414}, "tag_name": "a", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "refi64"}}]}, {"role": "link", "name": "16 days ago", "properties": {"url": "/c/9qhbce"}, "bounding_box": {"x": 275.3035888671875, "y": 2211.857177734375, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 25, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 275.3035888671875, "y": 2211.857177734375, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "16 days ago"}}]}, {"role": "link", "name": "State of Elixir 2025 - Community Survey Results", "properties": {"url": "/s/zwzwqn/state_elixir_2025_community_survey"}, "bounding_box": {"x": 375.76788330078125, "y": 2211.857177734375, "width": 270.25, "height": 14.285715103149414}, "tag_name": "a", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "State of Elixir 2025 - Community Survey Results"}}]}, {"role": "heading", "name": "My understanding of the Erlang/Elixir ecosystem is that Elixir has been a major entry point for a long time, and it ranks as more popular than Erlang in most surveys. I'm not sure if there's any other notable analogues in the word of programming languages. I don't think it's AI-generated, merely somewhat questionable. The \"drop-off\" is relative to Python, JS/TS, and Rust, and (as the article mentions) the usual reason to talk to python is for AI or data science-related things. Of course, the drop-off isn't that large\u2014it's going from ~16% to ~8%, which would just imply a wide variety of answers\u2014but I don't think it's entirely absurd either.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 2229, "width": 700.0000610351562, "height": 225.50001525878906}, "tag_name": "div", "id": 21, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 2233.196533203125, "width": 693.0000610351562, "height": 38.66071701049805}, "tag_name": "blockquote", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 2343.848388671875, "width": 693.0000610351562, "height": 19.330358505249023}, "tag_name": "blockquote", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "~8", "properties": {"url": "https://lobste.rs/~8"}, "bounding_box": {"x": 590.5982666015625, "y": 2410.5537109375, "width": 15.964286804199219, "height": 15.428571701049805}, "tag_name": "a", "id": 27, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "~8"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "My understanding of the Erlang/Elixir ecosystem is that Elixir has been a major entry point for a long time, and it ranks as more popular than Erlang in most surveys. I'm not sure if there's any other notable analogues in the word of programming languages. I don't think it's AI-generated, merely somewhat questionable. The \"drop-off\" is relative to Python, JS/TS, and Rust, and (as the article mentions) the usual reason to talk to python is for AI or data science-related things. Of course, the drop-off isn't that large\u2014it's going from ~16% to ~8%, which would just imply a wide variety of answers\u2014but I don't think it's entirely absurd either."}}]}, {"role": "link", "name": "\u25b3 12", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 2484.4912109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 21, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 12"}}]}, {"role": "link", "name": "yawaramin", "properties": {"url": "/~yawaramin"}, "bounding_box": {"x": 240.0982208251953, "y": 2468.77685546875, "width": 61.232147216796875, "height": 14.285715103149414}, "tag_name": "a", "id": 25, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "yawaramin"}}]}, {"role": "link", "name": "18 days ago", "properties": {"url": "/c/arizrt"}, "bounding_box": {"x": 304.8571472167969, "y": 2468.77685546875, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 26, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 304.8571472167969, "y": 2468.77685546875, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 27, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "18 days ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "What's the Point of Learning Functional Programming?", "properties": {"url": "/s/dljowr/what_s_point_learning_functional"}, "bounding_box": {"x": 405.3214416503906, "y": 2468.77685546875, "width": 307.1964416503906, "height": 14.285715103149414}, "tag_name": "a", "id": 25, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "What's the Point of Learning Functional Programming?", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "heading", "name": "Type-level reasoning is great, but it's not inherently a quality of functional programming. It's just that functional programming languages are often strongly statically typed with some advanced type-level features. But for example Ada and Rust have some pretty strong type-level features too, and they're not FP languages.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 2485.919677734375, "width": 700.0000610351562, "height": 69.1875}, "tag_name": "div", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Type-level reasoning is great, but it's not inherently a quality of functional programming. It's just that functional programming languages are often strongly statically typed with some advanced type-level features. But for example Ada and Rust have some pretty strong type-level features too, and they're not FP languages."}}]}, {"role": "link", "name": "\u25b3 30", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 2585.098388671875, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 30"}}]}, {"role": "link", "name": "david_chisnall", "properties": {"url": "/~david_chisnall"}, "bounding_box": {"x": 240.0982208251953, "y": 2569.384033203125, "width": 79.55357360839844, "height": 14.285715103149414}, "tag_name": "a", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "david_chisnall"}}]}, {"role": "link", "name": "18 days ago", "properties": {"url": "/c/5yg7ck"}, "bounding_box": {"x": 323.1785888671875, "y": 2569.384033203125, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 27, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 323.1785888671875, "y": 2569.384033203125, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "18 days ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "What's the Point of Learning Functional Programming?", "properties": {"url": "/s/dljowr/what_s_point_learning_functional"}, "bounding_box": {"x": 423.64288330078125, "y": 2569.384033203125, "width": 307.1964416503906, "height": 14.285715103149414}, "tag_name": "a", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "What's the Point of Learning Functional Programming?", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "heading", "name": "There\u2019s one other big benefit that I think this article touches on but I\u2019d highlight a bit more: type-level reasoning. Idiomatic Haskell tends to express constraints on the behaviour of the program in terms of types. Learning to think that way will make you write much better C++ or Rust. You will write code that has a much higher chance of working if it compiles (and, conversely, fails to compile if it is buggy). This is one of the most important skills in programming and one that you cannot easily teach in Python.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 2586.52685546875, "width": 700.0000610351562, "height": 121.84822082519531}, "tag_name": "div", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "There\u2019s one other big benefit that I think this article touches on but I\u2019d highlight a bit more: type-level reasoning. Idiomatic Haskell tends to express constraints on the behaviour of the program in terms of types. Learning to think that way will make you write much better C++ or Rust. You will write code that has a much higher chance of working if it compiles (and, conversely, fails to compile if it is buggy). This is one of the most important skills in programming and one that you cannot easily teach in Python."}}]}, {"role": "link", "name": "\u25b3 39", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 2738.3662109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 23, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 39"}}]}, {"role": "link", "name": "ssokolow", "properties": {"url": "/~ssokolow"}, "bounding_box": {"x": 240.0982208251953, "y": 2722.65185546875, "width": 52.080360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 27, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "ssokolow", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "19 days ago", "properties": {"url": "/c/osfdnz"}, "bounding_box": {"x": 333.7232360839844, "y": 2722.65185546875, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 28, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 333.7232360839844, "y": 2722.65185546875, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "19 days ago"}}]}, {"role": "link", "name": "Thoughts on Go vs. Rust vs. Zig", "properties": {"url": "/s/whiefr/thoughts_on_go_vs_rust_vs_zig"}, "bounding_box": {"x": 433.95538330078125, "y": 2722.65185546875, "width": 180.87501525878906, "height": 14.285715103149414}, "tag_name": "a", "id": 27, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Thoughts on Go vs. Rust vs. Zig"}}]}, {"role": "heading", "name": "Even that undersells it. \"Undefined Behaviour\" is behaviour that the compiler's optimizers have been promised will never happen. In the world of C, it's sometimes referred to as \"nasal demons\" because, upon encountering undefined behaviour, the compiler is allowed to do anything including making demons fly out of your nose. You can't check for it at runtime because it's not a property of your runtime semantics. It's a property of the \"algebra\" that the compiler performs to transform your code into a more efficient shape while preserving its observable properties before lowering it into machine instructions. It's, \"If you do this, then the compiler is allowed to see printf(\"Hello, World!\"); and silently emit the machine instructions corresponding to system(\"rm -rf /\")\" and it's done that way because the pathological cases are emergent behaviour... unanticipated crazy results from stacking up simple, reasonable changes. (It's basically the programming language version of an ant mill.) See Why undefined behavior may call a never-called function for an example of how this can happen in one shocking way in real C++ code. (The gist is \"I've been promised that this function pointer will not be called before it's been initialized. It's a local variable, so it can only be set by a function within this compilation unit. Logically, even if I can't see it, something must call this externally visible initializer before this code is reached, so I'll inline it.\") Creating an unguarded/unsynchronized mutable global variable (i.e. static mut) is so risky that there's an open RFC to deprecate the Rust language feature entirely. (It has to do with how easy it is to accidentally violate the aliasing rules the optimizer has been promised it can rely on via the same underlying LLVM IR annotations that C's restrict lowers to.) Creating a mutable static through the use of interior mutability is trivial. Just create a static that is non-mut and put your type T inside a Mutex<T> or RwLock<T>. There are even example code snippets in the Disallow references to static mut section of the migration guide for Rust 2024, because they switched the static_mut_refs lint to deny. See also: Mutable statics have scary superpowers! Do not use them Benign Data Races: What Could Possibly Go Wrong? Bear in mind that this sort of thing isn't just limited to the programming language itself. Undefined behaviour can also lead to the programming language not emitting the correct hints to the CPU that allow it to pretend it's a fast PDP/11 when it's really got a complex hierarchy of caches, pipelines, and speculative execution under the hood to fake a faster speed of light between the CPU and main RAM. ...when that happens, you can wind up with cache coherency bugs like this: Variable contains 5 Assign 6 to variable Read from variable and receive 5 Time passes but no further assignment is done to variable Read from variable and receive 6", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 2739.794677734375, "width": 700.0000610351562, "height": 938.732177734375}, "tag_name": "div", "id": 24, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 2743.9912109375, "width": 693.0000610351562, "height": 115.98214721679688}, "tag_name": "blockquote", "id": 25, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 554.607177734375, "y": 2999.2412109375, "width": 168, "height": 13.714286804199219}, "tag_name": "code", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 401.4464416503906, "y": 3018.571533203125, "width": 126.00000762939453, "height": 13.714286804199219}, "tag_name": "code", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "ant mill", "properties": {"url": "https://en.wikipedia.org/wiki/Ant_mill"}, "bounding_box": {"x": 473.83929443359375, "y": 3056.660888671875, "width": 44.34821701049805, "height": 15.428571701049805}, "tag_name": "a", "id": 32, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "ant mill"}}]}, {"role": "link", "name": "Why undefined behavior may call a never-called function", "properties": {"url": "https://kristerw.blogspot.com/2017/09/why-undefined-behavior-may-call-never.html"}, "bounding_box": {"x": 247.37501525878906, "y": 3082.9912109375, "width": 350.9732360839844, "height": 15.428571701049805}, "tag_name": "a", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Why undefined behavior may call a never-called function"}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 3184.9287109375, "width": 693.0000610351562, "height": 38.66071701049805}, "tag_name": "blockquote", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 642.75, "y": 3232.875244140625, "width": 70, "height": 13.714286804199219}, "tag_name": "code", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "open RFC", "properties": {"url": "https://github.com/rust-lang/rfcs/pull/3560"}, "bounding_box": {"x": 218.57144165039062, "y": 3232.3037109375, "width": 691.4017944335938, "height": 34.75893020629883}, "tag_name": "a", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "open RFC"}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 600.75, "y": 3297.8662109375, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 3}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 340.7589416503906, "y": 3324.196533203125, "width": 42, "height": 13.714286804199219}, "tag_name": "code", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 4}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 751.5982666015625, "y": 3324.196533203125, "width": 42, "height": 13.714286804199219}, "tag_name": "code", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 5}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 866.7500610351562, "y": 3324.196533203125, "width": 21, "height": 13.714286804199219}, "tag_name": "code", "id": 36, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 6}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 303.40179443359375, "y": 3343.52685546875, "width": 7.000000476837158, "height": 13.714286804199219}, "tag_name": "code", "id": 37, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 7}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 366.4375305175781, "y": 3343.52685546875, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 38, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 8}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 442.669677734375, "y": 3343.52685546875, "width": 63.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 39, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 9}}]}, {"role": "link", "name": "Disallow references to static mut", "properties": {"url": "https://doc.rust-lang.org/edition-guide/rust-2024/static-mut-references.html"}, "bounding_box": {"x": 218.57144165039062, "y": 3342.95556640625, "width": 630.8125, "height": 34.75893020629883}, "tag_name": "a", "id": 40, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Disallow references to static mut"}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 218.57144165039062, "y": 3382.187744140625, "width": 105.00000762939453, "height": 13.714286804199219}, "tag_name": "code", "id": 41, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 10}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 364.8214416503906, "y": 3382.187744140625, "width": 28.000001907348633, "height": 13.714286804199219}, "tag_name": "code", "id": 42, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 11}}]}, {"role": "link", "name": "Mutable statics have scary superpowers! Do not use them", "properties": {"url": "https://blog.kodewerx.org/2021/07/mutable-statics-have-scary-superpowers.html"}, "bounding_box": {"x": 258.5714416503906, "y": 3434.27685546875, "width": 359.5089416503906, "height": 15.428571701049805}, "tag_name": "a", "id": 37, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Mutable statics have scary superpowers! Do not use them"}}]}, {"role": "link", "name": "Benign Data Races: What Could Possibly Go Wrong?", "properties": {"url": "https://web.archive.org/web/20201108102846/https://software.intel.com/content/www/us/en/develop/blogs/benign-data-races-what-could-possibly-go-wrong.html"}, "bounding_box": {"x": 258.5714416503906, "y": 3453.607177734375, "width": 332.7946472167969, "height": 15.428571701049805}, "tag_name": "a", "id": 38, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Benign Data Races: What Could Possibly Go Wrong?"}}]}, {"role": "link", "name": "pretend it's a fast PDP/11", "properties": {"url": "https://queue.acm.org/detail.cfm?id=3212479"}, "bounding_box": {"x": 218.57144165039062, "y": 3499.26806640625, "width": 694.5000610351562, "height": 34.75893020629883}, "tag_name": "a", "id": 37, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "pretend it's a fast PDP/11"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Even that undersells it. \"Undefined Behaviour\" is behaviour that the compiler's optimizers have been promised will never happen. In the world of C, it's sometimes referred to as \"nasal demons\" because, upon encountering undefined behaviour, the compiler is allowed to do anything including making demons fly out of your nose. You can't check for it at runtime because it's not a property of your runtime semantics. It's a property of the \"algebra\" that the compiler performs to transform your code into a more efficient shape while preserving its observable properties before lowering it into machine instructions. It's, \"If you do this, then the compiler is allowed to see printf(\"Hello, World!\"); and silently emit the machine instructions corresponding to system(\"rm -rf /\")\" and it's done that way because the pathological cases are emergent behaviour... unanticipated crazy results from stacking up simple, reasonable changes. (It's basically the programming language version of an ant mill.) See Why undefined behavior may call a never-called function for an example of how this can happen in one shocking way in real C++ code. (The gist is \"I've been promised that this function pointer will not be called before it's been initialized. It's a local variable, so it can only be set by a function within this compilation unit. Logically, even if I can't see it, something must call this externally visible initializer before this code is reached, so I'll inline it.\") Creating an unguarded/unsynchronized mutable global variable (i.e. static mut) is so risky that there's an open RFC to deprecate the Rust language feature entirely. (It has to do with how easy it is to accidentally violate the aliasing rules the optimizer has been promised it can rely on via the same underlying LLVM IR annotations that C's restrict lowers to.) Creating a mutable static through the use of interior mutability is trivial. Just create a static that is non-mut and put your type T inside a Mutex<T> or RwLock<T>. There are even example code snippets in the Disallow references to static mut section of the migration guide for Rust 2024, because they switched the static_mut_refs lint to deny. See also: Mutable statics have scary superpowers! Do not use them Benign Data Races: What Could Possibly Go Wrong? Bear in mind that this sort of thing isn't just limited to the programming language itself. Undefined behaviour can also lead to the programming language not emitting the correct hints to the CPU that allow it to pretend it's a fast PDP/11 when it's really got a complex hierarchy of caches, pipelines, and speculative execution under the hood to fake a faster speed of light between the CPU and main RAM. ...when that happens, you can wind up with cache coherency bugs like this: Variable contains 5 Assign 6 to variable Read from variable and receive 5 Time passes but no further assignment is done to variable Read from variable and receive 6"}}]}, {"role": "link", "name": "\u25b3 4", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 3708.51806640625, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 24, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 4", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "justinpombrio", "properties": {"url": "/~justinpombrio"}, "bounding_box": {"x": 240.0982208251953, "y": 3692.8037109375, "width": 75.3125, "height": 14.285715103149414}, "tag_name": "a", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "justinpombrio"}}]}, {"role": "link", "name": "29 days ago", "properties": {"url": "/c/fa8zw8"}, "bounding_box": {"x": 318.9375, "y": 3692.8037109375, "width": 69, "height": 14.285715103149414}, "tag_name": "a", "id": 29, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 318.9375, "y": 3692.8037109375, "width": 69, "height": 14.285715103149414}, "tag_name": "time", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "29 days ago"}}]}, {"role": "link", "name": "Fifty Shades of OOP", "properties": {"url": "/s/fjf1eh/fifty_shades_oop"}, "bounding_box": {"x": 419.40179443359375, "y": 3692.8037109375, "width": 116.12500762939453, "height": 14.285715103149414}, "tag_name": "a", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Fifty Shades of OOP"}}]}, {"role": "heading", "name": "I'm really curious about this. I've heard it elsewhere too, inheritance as a means to re-use code that would otherwise be duplicated, but I've never understood it. Even when I was programming in Java long ago, I don't think I ever made one concrete type inherit from another, and I don't recall ever having issues with duplicated code. This across Python, OCaml, Java, Haskell, Pyret, Rust, C++. Are there features that these languages have that lets you avoid the problem? Is it the ability to have a \"default implementation\" of a method, like Rust allows directly and like you can achieve in Java by \"inheriting\" from an abstract base class? (I wouldn't really call that inheritance but if that's all that people meant when saying that inheritance is necessary to avoid duplicating code that I guess that explains it.) Did developers back in the day not realize that you could like... do composition by having one object contain another? Was it an artifact of the fact that Java bundles visibility together with class definitions, such that abstraction boundaries had to be class boundaries, making composition difficult to use while making an abstraction?", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 3709.946533203125, "width": 700.0000610351562, "height": 257.1607360839844}, "tag_name": "div", "id": 25, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 3714.14306640625, "width": 693.0000610351562, "height": 19.330358505249023}, "tag_name": "blockquote", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "I'm really curious about this. I've heard it elsewhere too, inheritance as a means to re-use code that would otherwise be duplicated, but I've never understood it. Even when I was programming in Java long ago, I don't think I ever made one concrete type inherit from another, and I don't recall ever having issues with duplicated code. This across Python, OCaml, Java, Haskell, Pyret, Rust, C++. Are there features that these languages have that lets you avoid the problem? Is it the ability to have a \"default implementation\" of a method, like Rust allows directly and like you can achieve in Java by \"inheriting\" from an abstract base class? (I wouldn't really call that inheritance but if that's all that people meant when saying that inheritance is necessary to avoid duplicating code that I guess that explains it.) Did developers back in the day not realize that you could like... do composition by having one object contain another? Was it an artifact of the fact that Java bundles visibility together with class definitions, such that abstraction boundaries had to be class boundaries, making composition difficult to use while making an abstraction?"}}]}, {"role": "link", "name": "\u25b3 9", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 3997.098388671875, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 25, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 9"}}]}, {"role": "link", "name": "pyon", "properties": {"url": "/~pyon"}, "bounding_box": {"x": 240.0982208251953, "y": 3981.384033203125, "width": 27.46428680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "pyon"}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/bqgcos"}, "bounding_box": {"x": 271.08929443359375, "y": 3981.384033203125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 30, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 271.08929443359375, "y": 3981.384033203125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "Why (pure) functional programming matters", "properties": {"url": "/s/n2ciff/why_pure_functional_programming_matters"}, "bounding_box": {"x": 372.95538330078125, "y": 3981.384033203125, "width": 244.2053680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Why (pure) functional programming matters", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "heading", "name": "IMO, functional programming itself is a red herring. Historically, the FP research community came up with some really good ideas, like algebraic data types and parametric polymorphism. More generally, anything that helps \u201cmake illegal states irrepresentable\u201d. But these are achievements of type theory, not of FP itself. And they can be readily applied to imperative languages as well (e.g., Rust). So, what's the essence of FP? It's two things: Using functions as first-class values: This is no different from object-oriented programming. All the usual criticisms of OOP's reliance on dynamically dispatched behavior can be levied at FP as well, and remain just as valid. If anything, FP's culture makes things worse, because FPers love coming up with clever ways to shoot yourself in the foot by messing with the control flow. From least to most harmful: First-class functions: combinators, recursion schemes, etc. Custom control operators: first-class continuations, algebraic effects and handlers, etc. Non-strict evaluation strategies. Language-building kits: macros, templates, fexprs, etc. Avoiding side effects: In principle, it's a commendable goal to restrict which parts of a program can have effects beyond locally transforming inputs into outputs. In practice, \u201cpure\u201d FP is a heavy-fisted way to achieve this goal. And you lose so much expressiveness that the standard \u201csolution\u201d, i.e., using an IO monad, boils down to embedding an unrestricted imperative language inside a \u201cpure functional\u201d metalanguage [0]. A more effective (pun not intended) solution than outright banning effects is to carefully control under which circumstances they may happen. Like how Rust controls mutation so that it doesn't break local reasoning, unless you explicitly request it (with RefCell or Mutex). Again, it's type theory that wins, not FP. [0] Monads were originally invented to give a denotational semantics to effectful, call-by-value languages inside a mathematical universe. For this theoretical purpose they're perfectly fine. However, when you define an IO monad in a library, you're trying to identify the mathematical universe with the programming language you're using. Alas, even \u201cpure\u201d functional languages differ from the mathematical universe in important ways that make the identification dangerous.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 3998.52685546875, "width": 700.0000610351562, "height": 570.7857666015625}, "tag_name": "div", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "IMO, functional programming itself is a red herring. Historically, the FP research community came up with some really good ideas, like algebraic data types and parametric polymorphism. More generally, anything that helps \u201cmake illegal states irrepresentable\u201d. But these are achievements of type theory, not of FP itself. And they can be readily applied to imperative languages as well (e.g., Rust). So, what's the essence of FP? It's two things: Using functions as first-class values: This is no different from object-oriented programming. All the usual criticisms of OOP's reliance on dynamically dispatched behavior can be levied at FP as well, and remain just as valid. If anything, FP's culture makes things worse, because FPers love coming up with clever ways to shoot yourself in the foot by messing with the control flow. From least to most harmful: First-class functions: combinators, recursion schemes, etc. Custom control operators: first-class continuations, algebraic effects and handlers, etc. Non-strict evaluation strategies. Language-building kits: macros, templates, fexprs, etc. Avoiding side effects: In principle, it's a commendable goal to restrict which parts of a program can have effects beyond locally transforming inputs into outputs. In practice, \u201cpure\u201d FP is a heavy-fisted way to achieve this goal. And you lose so much expressiveness that the standard \u201csolution\u201d, i.e., using an IO monad, boils down to embedding an unrestricted imperative language inside a \u201cpure functional\u201d metalanguage [0]. A more effective (pun not intended) solution than outright banning effects is to carefully control under which circumstances they may happen. Like how Rust controls mutation so that it doesn't break local reasoning, unless you explicitly request it (with RefCell or Mutex). Again, it's type theory that wins, not FP. [0] Monads were originally invented to give a denotational semantics to effectful, call-by-value languages inside a mathematical universe. For this theoretical purpose they're perfectly fine. However, when you define an IO monad in a library, you're trying to identify the mathematical universe with the programming language you're using. Alas, even \u201cpure\u201d functional languages differ from the mathematical universe in important ways that make the identification dangerous."}}]}, {"role": "link", "name": "\u25b3 8", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 4599.3037109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 26, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 8"}}]}, {"role": "link", "name": "chreke", "properties": {"url": "/~chreke"}, "bounding_box": {"x": 240.0982208251953, "y": 4583.58935546875, "width": 38.00893020629883, "height": 14.285715103149414}, "tag_name": "a", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "chreke"}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/vm6jeo"}, "bounding_box": {"x": 281.6339416503906, "y": 4583.58935546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 31, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 281.6339416503906, "y": 4583.58935546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 32, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "Why (pure) functional programming matters", "properties": {"url": "/s/n2ciff/why_pure_functional_programming_matters"}, "bounding_box": {"x": 383.5000305175781, "y": 4583.58935546875, "width": 244.2053680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Why (pure) functional programming matters", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "heading", "name": "I was actually unsure whether to include this or not, as it feels like beating a dead horse by now. Still, I think it shows the utiliy of effect systems / being able to sight-read whether a function is impure or not. This is a good point, and something I have struggled with myself\u2014there is a certain \"aesthetic\" which really isn't bound to FP; Rust shares more of this aesthetic with ML than with Clojure, in spite of Clojure being \"functional programming\" whereas Rust really isn't. I think we need a better name for this. Yeah, this is very much based on anecdata and vibes. However, I think it's not controversial to say that in the presence of unmanaged effects, the complexity of understanding any given function is O(n). We stopped using global variables for a reason, and I think that same reason also applies to unmanaged effects. I do wish that there were more studies on this, but they seem scarce, and those that exist are often plagued by methodological issues (see https://danluu.com/empirical-pl/). I think it's quite uncontroversial to say that if the type system is powerful enough you only need to read the function definition to understand what a function does? Ergo, in order for an LLM to update a function it only needs to load the definition into its context.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 4600.732421875, "width": 700.0000610351562, "height": 408.14288330078125}, "tag_name": "div", "id": 27, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 4604.9287109375, "width": 693.0000610351562, "height": 38.66071701049805}, "tag_name": "blockquote", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 4696.25, "width": 693.0000610351562, "height": 19.330358505249023}, "tag_name": "blockquote", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 4787.57177734375, "width": 693.0000610351562, "height": 19.330358505249023}, "tag_name": "blockquote", "id": 32, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "https://danluu.com/empirical-pl/", "properties": {"url": "https://danluu.com/empirical-pl/"}, "bounding_box": {"x": 293.26788330078125, "y": 4892.9375, "width": 193.75894165039062, "height": 15.428571701049805}, "tag_name": "a", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "https://danluu.com/empirical-pl/"}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 4917.5537109375, "width": 693.0000610351562, "height": 19.330358505249023}, "tag_name": "blockquote", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 3}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "I was actually unsure whether to include this or not, as it feels like beating a dead horse by now. Still, I think it shows the utiliy of effect systems / being able to sight-read whether a function is impure or not. This is a good point, and something I have struggled with myself\u2014there is a certain \"aesthetic\" which really isn't bound to FP; Rust shares more of this aesthetic with ML than with Clojure, in spite of Clojure being \"functional programming\" whereas Rust really isn't. I think we need a better name for this. Yeah, this is very much based on anecdata and vibes. However, I think it's not controversial to say that in the presence of unmanaged effects, the complexity of understanding any given function is O(n). We stopped using global variables for a reason, and I think that same reason also applies to unmanaged effects. I do wish that there were more studies on this, but they seem scarce, and those that exist are often plagued by methodological issues (see https://danluu.com/empirical-pl/). I think it's quite uncontroversial to say that if the type system is powerful enough you only need to read the function definition to understand what a function does? Ergo, in order for an LLM to update a function it only needs to load the definition into its context."}}]}, {"role": "link", "name": "\u25b3 10", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 5038.8662109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 27, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 10", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "imcquee", "properties": {"url": "/~imcquee"}, "bounding_box": {"x": 240.0982208251953, "y": 5023.15185546875, "width": 47.86607360839844, "height": 14.285715103149414}, "tag_name": "a", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "imcquee"}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/8l3ox5"}, "bounding_box": {"x": 291.4910888671875, "y": 5023.15185546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 32, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 291.4910888671875, "y": 5023.15185546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "Why (pure) functional programming matters", "properties": {"url": "/s/n2ciff/why_pure_functional_programming_matters"}, "bounding_box": {"x": 393.3571472167969, "y": 5023.15185546875, "width": 244.2053680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Why (pure) functional programming matters", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "heading", "name": "That's the real value here. This should be what's mentioned when you campaign for any kind of strictness in software period. Turing complete is Turing complete. You're not going convince someone that functional programs are by nature superior just because you said so. \"I don't need functional programming, Rust/Java/TS/C++ already have this...\" You also don't need static type checking. A talented python or js developer can create just as robust software as a Rust developer. But we usually work in teams, and it's very hard to maintain this level of consistency and trust. This is the exact same argument in favor of strictness when it comes to fp. For every guarantee, we take a bit of mental load off and can tackle more and more complex problems with more confidence. By the way, they do state all of this in the video, maybe the examples weren't the best, but I still think it's a solid argument.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 5040.294921875, "width": 700.0000610351562, "height": 251.8303680419922}, "tag_name": "div", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "That's the real value here. This should be what's mentioned when you campaign for any kind of strictness in software period. Turing complete is Turing complete. You're not going convince someone that functional programs are by nature superior just because you said so. \"I don't need functional programming, Rust/Java/TS/C++ already have this...\" You also don't need static type checking. A talented python or js developer can create just as robust software as a Rust developer. But we usually work in teams, and it's very hard to maintain this level of consistency and trust. This is the exact same argument in favor of strictness when it comes to fp. For every guarantee, we take a bit of mental load off and can tackle more and more complex problems with more confidence. By the way, they do state all of this in the video, maybe the examples weren't the best, but I still think it's a solid argument."}}]}, {"role": "link", "name": "\u25b3 3", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 5322.1162109375, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 28, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 3", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "inactive-user", "properties": {"url": "/~inactive-user"}, "bounding_box": {"x": 240.0982208251953, "y": 5306.40185546875, "width": 71.78572082519531, "height": 14.285715103149414}, "tag_name": "a", "id": 32, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "inactive-user"}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/nvgclr"}, "bounding_box": {"x": 353.4285888671875, "y": 5306.40185546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 33, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 353.4285888671875, "y": 5306.40185546875, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 3}}]}, {"role": "link", "name": "What Killed Perl?", "properties": {"url": "/s/0m6yln/what_killed_perl"}, "bounding_box": {"x": 455.294677734375, "y": 5306.40185546875, "width": 97.12500762939453, "height": 14.285715103149414}, "tag_name": "a", "id": 32, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "What Killed Perl?"}}]}, {"role": "heading", "name": "In my earlier carrier, I wrote plenty of Perl, and I hated every minute of it. It's a language that I've almost forgotten, and this hasn't happened with other programming languages. For me, Perl was replaced by Python and Ruby for all my scripting needs (in my mind Ruby has been Perl 6), and more recently the static languages that I love (e.g., Scala, TypeScript, even Rust) can also be used for scripting. I mean, I hate Perl almost as much as I hate Bash, but I still interact with Bash because I'm forced to. I dreamed of Perl 6 though. It seemed like the upgrade we needed, and it was very ambitious as well, with its own VM designed for dynamic languages \u2014 this was back when the CLR was making waves for being designed for multiple languages (which never happened, the JVM took that spot, and now WASM). I do respect Perl's community and their output, they are great. I just hate the language.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 5323.544921875, "width": 700.0000610351562, "height": 206.16964721679688}, "tag_name": "div", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "In my earlier carrier, I wrote plenty of Perl, and I hated every minute of it. It's a language that I've almost forgotten, and this hasn't happened with other programming languages. For me, Perl was replaced by Python and Ruby for all my scripting needs (in my mind Ruby has been Perl 6), and more recently the static languages that I love (e.g., Scala, TypeScript, even Rust) can also be used for scripting. I mean, I hate Perl almost as much as I hate Bash, but I still interact with Bash because I'm forced to. I dreamed of Perl 6 though. It seemed like the upgrade we needed, and it was very ambitious as well, with its own VM designed for dynamic languages \u2014 this was back when the CLR was making waves for being designed for multiple languages (which never happened, the JVM took that spot, and now WASM). I do respect Perl's community and their output, they are great. I just hate the language."}}]}, {"role": "link", "name": "\u25b3 4", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 5559.70556640625, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 29, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 4", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "ssokolow", "properties": {"url": "/~ssokolow"}, "bounding_box": {"x": 240.0982208251953, "y": 5543.9912109375, "width": 52.080360412597656, "height": 14.285715103149414}, "tag_name": "a", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "ssokolow", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/3gumiz"}, "bounding_box": {"x": 333.7232360839844, "y": 5543.9912109375, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 34, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 333.7232360839844, "y": 5543.9912109375, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 4}}]}, {"role": "link", "name": "crux: Cross-platform app development in Rust", "properties": {"url": "/s/pffunn/crux_cross_platform_app_development_rust"}, "bounding_box": {"x": 435.58929443359375, "y": 5543.9912109375, "width": 257.58929443359375, "height": 14.285715103149414}, "tag_name": "a", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "crux: Cross-platform app development in Rust"}}]}, {"role": "heading", "name": "As a firm believer in the value of the decades of \"embodied expertise\" in an API like Qt QWidget, this statement hits me as if it were \"Crux recognizes that the best experiences are written in raw assembly language\". (i.e. If you define \"best\" in a very specific and simplistic way that prioritizes potential benefits relating to performance or ease of implementing custom widgets over all the downsides to working at a low level instead of using mature, well-exercised libraries. In other other words, if you grossly underestimate all the work that goes into achieving consistency with other implementations of a HIG and then just say \"good enough\".) I'm reminded of this bit from Things You Should Never Do, Part I: (See also this Twitter thread on SwiftUI once archive.org stops 503-ing, for examples of how even Apple isn't immune to this problem.) Heck, that's why my UI toolkit for Rust projects is \"Use PyO3 to treat PyQt/PySide+MyPy on Rust the way QML on C++ is promoted\". For me, memory-safe QWidget bindings are the non-negotiable part. (I really wish someone would revive and finish Ritual and Rust-Qt.) I am so tired of having to use yet another incomplete \"works for the parts I use\" implementation of list widget behaviour, or a drag-and-drop system that's missing the internal implementation of intra-window drag-and-drop to not require a pause to wait for \"X11 window using inter-window DnD APIs to negotiate with itself\" to catch up or it'll abort your drag, or a clipboard/DnD mimetype negotiation implementation that lacks all the hack-arounds for the various applications that don't quite follow the spec for putting [lists of] files on the clipboard. (eg. \\n vs. \\r\\n) (X11 SELECTION (middle-click to paste selected text) was broken for years on anything based on Chromium and its derivatives and I just mean generally. Middle-clicking after selecting text in anything based on the Chromium codebase was like rolling dice.) ...but sure. I seem to be in the minority in thinking that UI/UX design has been slowly rotting since 2001, when Steve Jobs introducing OS X (and its fast-and-looseness with their own HIG), web tech UIs encouraging wheel-reinvention, and attempts at mobile convergence started to assemble into UI/UX aqua regia. RIP, UI-design sanity.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 5561.13427734375, "width": 700.0000610351562, "height": 822.7500610351562}, "tag_name": "div", "id": 30, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 5565.33056640625, "width": 693.0000610351562, "height": 38.66071701049805}, "tag_name": "blockquote", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "link", "name": "Things You Should Never Do, Part I", "properties": {"url": "https://www.joelonsoftware.com/2000/04/06/things-you-should-never-do-part-i/"}, "bounding_box": {"x": 394.5000305175781, "y": 5742.68798828125, "width": 221.02679443359375, "height": 15.428571701049805}, "tag_name": "a", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Things You Should Never Do, Part I"}}]}, {"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 5767.3037109375, "width": 693.0000610351562, "height": 245.96429443359375}, "tag_name": "blockquote", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "this Twitter thread on SwiftUI", "properties": {"url": "https://web.archive.org/web/20230103193104/https://twitter.com/nikitonsky/status/1557357661171204098"}, "bounding_box": {"x": 281.6071472167969, "y": 6021.982421875, "width": 177.92857360839844, "height": 15.428571701049805}, "tag_name": "a", "id": 37, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "this Twitter thread on SwiftUI"}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 842.2767944335938, "y": 6210.52685546875, "width": 14.000000953674316, "height": 13.714286804199219}, "tag_name": "code", "id": 40, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 0}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 881.9464721679688, "y": 6210.52685546875, "width": 28.000001907348633, "height": 13.714286804199219}, "tag_name": "code", "id": 41, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 251.00001525878906, "y": 6236.857421875, "width": 63.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 40, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": "", "exact": true}}, {"selector": "nth", "parameters": {"index": 2}}]}, {"role": "link", "name": "fast-and-looseness with their own HIG", "properties": {"url": "https://daringfireball.net/2004/10/brushed-metal"}, "bounding_box": {"x": 451.2500305175781, "y": 6320.607421875, "width": 236.5535888671875, "height": 15.428571701049805}, "tag_name": "a", "id": 41, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "fast-and-looseness with their own HIG"}}]}, {"role": "link", "name": "RIP, UI-design sanity", "properties": {"url": "https://tonsky.me/blog/checkbox/"}, "bounding_box": {"x": 218.57144165039062, "y": 6339.93798828125, "width": 662.7767944335938, "height": 34.75893020629883}, "tag_name": "a", "id": 42, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "RIP, UI-design sanity"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "As a firm believer in the value of the decades of \"embodied expertise\" in an API like Qt QWidget, this statement hits me as if it were \"Crux recognizes that the best experiences are written in raw assembly language\". (i.e. If you define \"best\" in a very specific and simplistic way that prioritizes potential benefits relating to performance or ease of implementing custom widgets over all the downsides to working at a low level instead of using mature, well-exercised libraries. In other other words, if you grossly underestimate all the work that goes into achieving consistency with other implementations of a HIG and then just say \"good enough\".) I'm reminded of this bit from Things You Should Never Do, Part I: (See also this Twitter thread on SwiftUI once archive.org stops 503-ing, for examples of how even Apple isn't immune to this problem.) Heck, that's why my UI toolkit for Rust projects is \"Use PyO3 to treat PyQt/PySide+MyPy on Rust the way QML on C++ is promoted\". For me, memory-safe QWidget bindings are the non-negotiable part. (I really wish someone would revive and finish Ritual and Rust-Qt.) I am so tired of having to use yet another incomplete \"works for the parts I use\" implementation of list widget behaviour, or a drag-and-drop system that's missing the internal implementation of intra-window drag-and-drop to not require a pause to wait for \"X11 window using inter-window DnD APIs to negotiate with itself\" to catch up or it'll abort your drag, or a clipboard/DnD mimetype negotiation implementation that lacks all the hack-arounds for the various applications that don't quite follow the spec for putting [lists of] files on the clipboard. (eg. \\n vs. \\r\\n) (X11 SELECTION (middle-click to paste selected text) was broken for years on anything based on Chromium and its derivatives and I just mean generally. Middle-clicking after selecting text in anything based on the Chromium codebase was like rolling dice.) ...but sure. I seem to be in the minority in thinking that UI/UX design has been slowly rotting since 2001, when Steve Jobs introducing OS X (and its fast-and-looseness with their own HIG), web tech UIs encouraging wheel-reinvention, and attempts at mobile convergence started to assemble into UI/UX aqua regia. RIP, UI-design sanity."}}]}, {"role": "link", "name": "\u25b3 6", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 6413.87548828125, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 30, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 6"}}]}, {"role": "link", "name": "HansHalverson", "properties": {"url": "/~HansHalverson"}, "bounding_box": {"x": 240.0982208251953, "y": 6398.1611328125, "width": 86.5714340209961, "height": 14.285715103149414}, "tag_name": "a", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "HansHalverson"}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/zl8ulx"}, "bounding_box": {"x": 368.21429443359375, "y": 6398.1611328125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 35, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 368.21429443359375, "y": 6398.1611328125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 36, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 5}}]}, {"role": "link", "name": "brimstone: New JavaScript engine written in Rust", "properties": {"url": "/s/ddhd8c/brimstone_new_javascript_engine_written"}, "bounding_box": {"x": 470.08038330078125, "y": 6398.1611328125, "width": 275.89288330078125, "height": 14.285715103149414}, "tag_name": "a", "id": 34, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "brimstone: New JavaScript engine written in Rust"}}]}, {"role": "heading", "name": "Speaking for myself and Brimstone - I really just started it to have fun, learn, and as a challenge for myself! I've had a strong interest in compilers/languages/runtimes for a while and had spent the previous few years building my own programming language. I was looking for a new project, wanted to try our writing more of a VM/runtime as I never had written one before, and thought that if I'm already willing to spent so much time/effort I might as well apply it towards a language people actually use (and that I use every day). I was also pretty directly inspired by Andreas Kling's story with SerenityOS/Ladybird and I think seeing their work was part of my initial kick to get started. I also generally have a fascination with building from scratch some of the tools I use every day in order to feel like I fully know how they work, top to bottom. I also wanted to learn Rust as I'd only dabbled before. But Brimstone at least didn't have any explicit goals at the start other than learning and seeing what I could do. I just ended up really loving the work and kept going, hoping to end up with a complete, pretty good JS engine.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 6415.3037109375, "width": 700.0000610351562, "height": 237.8303680419922}, "tag_name": "div", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Speaking for myself and Brimstone - I really just started it to have fun, learn, and as a challenge for myself! I've had a strong interest in compilers/languages/runtimes for a while and had spent the previous few years building my own programming language. I was looking for a new project, wanted to try our writing more of a VM/runtime as I never had written one before, and thought that if I'm already willing to spent so much time/effort I might as well apply it towards a language people actually use (and that I use every day). I was also pretty directly inspired by Andreas Kling's story with SerenityOS/Ladybird and I think seeing their work was part of my initial kick to get started. I also generally have a fascination with building from scratch some of the tools I use every day in order to feel like I fully know how they work, top to bottom. I also wanted to learn Rust as I'd only dabbled before. But Brimstone at least didn't have any explicit goals at the start other than learning and seeing what I could do. I just ended up really loving the work and kept going, hoping to end up with a complete, pretty good JS engine."}}]}, {"role": "link", "name": "\u25b3 18", "properties": {"url": "/login"}, "bounding_box": {"x": 191.96429443359375, "y": 6683.12548828125, "width": 19.205358505249023, "height": 38.66071701049805}, "tag_name": "a", "id": 31, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "\u25b3 18"}}]}, {"role": "link", "name": "BenjaminRi", "properties": {"url": "/~BenjaminRi"}, "bounding_box": {"x": 240.0982208251953, "y": 6667.4111328125, "width": 64.75, "height": 14.285715103149414}, "tag_name": "a", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "BenjaminRi", "exact": true}}, {"selector": "nth", "parameters": {"index": 1}}]}, {"role": "link", "name": "1 month ago", "properties": {"url": "/c/qaoxgv"}, "bounding_box": {"x": 308.375, "y": 6667.4111328125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "a", "id": 36, "children": [{"role": "time", "name": "", "properties": {}, "bounding_box": {"x": 308.375, "y": 6667.4111328125, "width": 70.40178680419922, "height": 14.285715103149414}, "tag_name": "time", "id": 37, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "time", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1 month ago", "exact": true}}, {"selector": "nth", "parameters": {"index": 6}}]}, {"role": "link", "name": "Cloudflare outage on November 18, 2025", "properties": {"url": "/s/nac5wa/cloudflare_outage_on_november_18_2025"}, "bounding_box": {"x": 410.2410888671875, "y": 6667.4111328125, "width": 232.31251525878906, "height": 14.285715103149414}, "tag_name": "a", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Cloudflare outage on November 18, 2025"}}]}, {"role": "heading", "name": "Think about what would have happened if this reckless code was written in C++. Instead of unwrap(), the programmer would have probably used the result unconditionally, even if the file failed to load. At that point, all the Cloudflare servers would have probably run on Bot Management feature files that consisted of random, garbage memory if they didn't crash outright. Overall, this is simply bad programming and the best language on the planet will not save you from that. The computer does what you instruct it to do.", "properties": {"level": 3}, "bounding_box": {"x": 218.57144165039062, "y": 6684.5537109375, "width": 700.0000610351562, "height": 153.50894165039062}, "tag_name": "div", "id": 32, "children": [{"role": "blockquote", "name": "", "properties": {}, "bounding_box": {"x": 225.57144165039062, "y": 6688.75048828125, "width": 693.0000610351562, "height": 38.66071701049805}, "tag_name": "blockquote", "id": 33, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "blockquote", "name": ""}}]}, {"role": "code", "name": "", "properties": {}, "bounding_box": {"x": 784.3482666015625, "y": 6736.69677734375, "width": 56.000003814697266, "height": 13.714286804199219}, "tag_name": "code", "id": 35, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "code", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "heading", "name": "Think about what would have happened if this reckless code was written in C++. Instead of unwrap(), the programmer would have probably used the result unconditionally, even if the file failed to load. At that point, all the Cloudflare servers would have probably run on Bot Management feature files that consisted of random, garbage memory if they didn't crash outright. Overall, this is simply bad programming and the best language on the planet will not save you from that. The computer does what you instruct it to do."}}]}, {"role": "link", "name": "1", "properties": {"url": "/search?order=newest&page=1&q=rust+programming&what=comments"}, "bounding_box": {"x": 261.9107360839844, "y": 6867.8662109375, "width": 18.553571701049805, "height": 22.660715103149414}, "tag_name": "a", "id": 8, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "1", "exact": true}}]}, {"role": "link", "name": "2", "properties": {"url": "/search?order=newest&page=2&q=rust+programming&what=comments"}, "bounding_box": {"x": 290.83038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 9, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "2", "exact": true}}]}, {"role": "link", "name": "3", "properties": {"url": "/search?order=newest&page=3&q=rust+programming&what=comments"}, "bounding_box": {"x": 323.08038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 10, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "3", "exact": true}}]}, {"role": "link", "name": "4", "properties": {"url": "/search?order=newest&page=4&q=rust+programming&what=comments"}, "bounding_box": {"x": 355.33038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 11, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "4", "exact": true}}]}, {"role": "link", "name": "5", "properties": {"url": "/search?order=newest&page=5&q=rust+programming&what=comments"}, "bounding_box": {"x": 387.58038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 12, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "5", "exact": true}}]}, {"role": "link", "name": "6", "properties": {"url": "/search?order=newest&page=6&q=rust+programming&what=comments"}, "bounding_box": {"x": 419.83038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 13, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "6", "exact": true}}]}, {"role": "link", "name": "7", "properties": {"url": "/search?order=newest&page=7&q=rust+programming&what=comments"}, "bounding_box": {"x": 452.08038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 14, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "7", "exact": true}}]}, {"role": "link", "name": "8", "properties": {"url": "/search?order=newest&page=8&q=rust+programming&what=comments"}, "bounding_box": {"x": 484.33038330078125, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 15, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "8", "exact": true}}]}, {"role": "link", "name": "9", "properties": {"url": "/search?order=newest&page=9&q=rust+programming&what=comments"}, "bounding_box": {"x": 516.5803833007812, "y": 6867.8662109375, "width": 21.883930206298828, "height": 22.660715103149414}, "tag_name": "a", "id": 16, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "9", "exact": true}}]}, {"role": "link", "name": "10", "properties": {"url": "/search?order=newest&page=10&q=rust+programming&what=comments"}, "bounding_box": {"x": 548.8303833007812, "y": 6867.8662109375, "width": 29.29464340209961, "height": 22.660715103149414}, "tag_name": "a", "id": 17, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "10", "exact": true}}]}, {"role": "link", "name": "11", "properties": {"url": "/search?order=newest&page=11&q=rust+programming&what=comments"}, "bounding_box": {"x": 588.4910888671875, "y": 6867.8662109375, "width": 28.562501907348633, "height": 22.660715103149414}, "tag_name": "a", "id": 18, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "11"}}]}, {"role": "link", "name": "12", "properties": {"url": "/search?order=newest&page=12&q=rust+programming&what=comments"}, "bounding_box": {"x": 627.419677734375, "y": 6867.8662109375, "width": 29.29464340209961, "height": 22.660715103149414}, "tag_name": "a", "id": 19, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "12", "exact": true}}]}, {"role": "link", "name": "13", "properties": {"url": "/search?order=newest&page=13&q=rust+programming&what=comments"}, "bounding_box": {"x": 667.0803833007812, "y": 6867.8662109375, "width": 29.29464340209961, "height": 22.660715103149414}, "tag_name": "a", "id": 20, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "13", "exact": true}}]}, {"role": "link", "name": "20", "properties": {"url": "/search?order=newest&page=20&q=rust+programming&what=comments"}, "bounding_box": {"x": 736.0267944335938, "y": 6867.8662109375, "width": 29.29464340209961, "height": 22.660715103149414}, "tag_name": "a", "id": 22, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "20", "exact": true}}]}, {"role": "contentinfo", "name": "", "properties": {}, "bounding_box": {"x": 182.57144165039062, "y": 6897.38427734375, "width": 900.0000610351562, "height": 72.65178680419922}, "tag_name": "footer", "id": 3, "children": [{"role": "link", "name": "About", "properties": {"url": "/about"}, "bounding_box": {"x": 839.5178833007812, "y": 6925.75927734375, "width": 44.83928680419922, "height": 14.85714340209961}, "tag_name": "a", "id": 6, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "About"}}]}, {"role": "link", "name": "Tags", "properties": {"url": "/tags"}, "bounding_box": {"x": 888.0625610351562, "y": 6925.75927734375, "width": 38.16071701049805, "height": 14.85714340209961}, "tag_name": "a", "id": 7, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Tags"}}]}, {"role": "link", "name": "Filter", "properties": {"url": "/filters"}, "bounding_box": {"x": 929.9285888671875, "y": 6925.75927734375, "width": 39.625, "height": 14.85714340209961}, "tag_name": "a", "id": 8, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Filter"}}]}, {"role": "link", "name": "Moderation Log", "properties": {"url": "/moderations"}, "bounding_box": {"x": 973.2589721679688, "y": 6925.75927734375, "width": 102.65178680419922, "height": 14.85714340209961}, "tag_name": "a", "id": 9, "children": [], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "link", "name": "Moderation Log"}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "contentinfo", "name": ""}}]}], "locator_parts": [{"selector": "get_by_role", "parameters": {"role": "document"}}]}